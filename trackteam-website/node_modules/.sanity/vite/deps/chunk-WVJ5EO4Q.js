import {
  AddCircleIcon,
  Ae,
  AvatarStack,
  BinaryDocumentIcon,
  BoundaryElementProvider,
  Box,
  Button,
  Card,
  ChangeFieldWrapper,
  ChangeList,
  CheckmarkCircleIcon,
  CheckmarkIcon,
  ChevronDownIcon,
  ClipboardIcon,
  CloseIcon,
  CommandList,
  ComposeIcon,
  Container,
  CopyIcon,
  DEFAULT_STUDIO_CLIENT_OPTIONS,
  Dialog,
  DiffTooltip,
  DocumentChangeContext,
  DocumentPreviewPresence,
  DocumentsIcon,
  EMPTY,
  EMPTY_ARRAY$7,
  EMPTY_OBJECT,
  EarthAmericasIcon,
  EditIcon,
  EllipsisVerticalIcon,
  ErrorBoundary,
  ErrorOutlineIcon,
  FieldActionsProvider,
  FieldActionsResolver,
  Flex,
  Grid,
  InfoOutlineIcon,
  Inline,
  InsufficientPermissionsMessage,
  IntentLink,
  Label,
  Layer,
  LayerProvider,
  LegacyLayerProvider,
  MasterDetailIcon,
  Menu,
  MenuButton,
  MenuDivider,
  MenuGroup,
  MenuItem,
  NoChanges,
  Popover,
  PreviewCard$1,
  PublishIcon,
  ResetIcon,
  RestoreIcon,
  SanityDefaultPreview,
  ScrollContainer,
  SelectIcon,
  SortIcon,
  Spinner,
  Stack,
  StackCompactIcon,
  StackIcon,
  StateLink,
  StatusButton,
  Text,
  TextSkeleton,
  TextWithTone,
  Tooltip,
  TooltipOfDisabled,
  TrashIcon,
  UnknownIcon,
  UnpublishIcon,
  UserAvatar,
  WarningOutlineIcon,
  catchError,
  createHookFromObservableFactory,
  debounceTime,
  definePlugin,
  distinctUntilChanged,
  format,
  from,
  fromEvent,
  fromString,
  getConfigContextFromSource,
  getDraftId,
  getExpandOperations,
  getPreviewStateObservable,
  getPreviewValueWithFallback,
  getPublishedId,
  isActionEnabled,
  isArray,
  isRecord$2,
  isValidationError,
  isValidationErrorMarker,
  isValidationWarning,
  map,
  of,
  pathToString,
  rem,
  require_baseGetTag,
  require_capitalize,
  require_createCompounder,
  require_find,
  require_isObjectLike,
  require_isString,
  require_jsx_runtime,
  require_lib,
  require_negate,
  require_omit,
  require_pickBy,
  require_react_is,
  require_speakingurl,
  require_startCase,
  require_uniq,
  require_uniqBy,
  require_uniqueId,
  require_upperFirst,
  resolveKeyedPath,
  rgba,
  route,
  setAtPath,
  shareReplay,
  startWith,
  styled_components_browser_esm_default,
  switchMap,
  timer,
  toMutationPatches,
  toString,
  useAsObservable,
  useClickOutside,
  useClient,
  useConfigContextFromSource,
  useConnectionState,
  useCurrentUser,
  useDocumentOperation,
  useDocumentPairPermissions,
  useDocumentPresence,
  useDocumentPreview,
  useDocumentPreviewStore,
  useDocumentStore,
  useDocumentValuePermissions,
  useEditState,
  useElementRect,
  useFormState,
  useForwardedRef,
  useGlobalKeyDown,
  useInitialValue,
  useIntentLink,
  useMemoObservable,
  usePresenceStore,
  useRouter,
  useSchema,
  useSource,
  useSyncState,
  useTemplatePermissions,
  useTemplates,
  useTimeAgo,
  useTimelineSelector,
  useTimelineStore,
  useToast,
  useUnique,
  useValidationStatus,
  v4_default,
  visitDiff
} from "./chunk-ACKCUSCU.js";
import {
  require_react
} from "./chunk-Z7L3MLVS.js";
import {
  __commonJS,
  __toESM
} from "./chunk-AUZ3RYOM.js";

// node_modules/lodash/isNumber.js
var require_isNumber = __commonJS({
  "node_modules/lodash/isNumber.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var numberTag = "[object Number]";
    function isNumber2(value) {
      return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
    }
    module.exports = isNumber2;
  }
});

// node_modules/lodash/camelCase.js
var require_camelCase = __commonJS({
  "node_modules/lodash/camelCase.js"(exports, module) {
    var capitalize = require_capitalize();
    var createCompounder = require_createCompounder();
    var camelCase2 = createCompounder(function(result, word, index) {
      word = word.toLowerCase();
      return result + (index ? capitalize(word) : word);
    });
    module.exports = camelCase2;
  }
});

// node_modules/lodash/kebabCase.js
var require_kebabCase = __commonJS({
  "node_modules/lodash/kebabCase.js"(exports, module) {
    var createCompounder = require_createCompounder();
    var kebabCase2 = createCompounder(function(result, word, index) {
      return result + (index ? "-" : "") + word.toLowerCase();
    });
    module.exports = kebabCase2;
  }
});

// node_modules/toggle-selection/index.js
var require_toggle_selection = __commonJS({
  "node_modules/toggle-selection/index.js"(exports, module) {
    module.exports = function() {
      var selection = document.getSelection();
      if (!selection.rangeCount) {
        return function() {
        };
      }
      var active = document.activeElement;
      var ranges = [];
      for (var i = 0; i < selection.rangeCount; i++) {
        ranges.push(selection.getRangeAt(i));
      }
      switch (active.tagName.toUpperCase()) {
        case "INPUT":
        case "TEXTAREA":
          active.blur();
          break;
        default:
          active = null;
          break;
      }
      selection.removeAllRanges();
      return function() {
        selection.type === "Caret" && selection.removeAllRanges();
        if (!selection.rangeCount) {
          ranges.forEach(function(range) {
            selection.addRange(range);
          });
        }
        active && active.focus();
      };
    };
  }
});

// node_modules/copy-to-clipboard/index.js
var require_copy_to_clipboard = __commonJS({
  "node_modules/copy-to-clipboard/index.js"(exports, module) {
    "use strict";
    var deselectCurrent = require_toggle_selection();
    var clipboardToIE11Formatting = {
      "text/plain": "Text",
      "text/html": "Url",
      "default": "Text"
    };
    var defaultMessage = "Copy to clipboard: #{key}, Enter";
    function format2(message) {
      var copyKey = (/mac os x/i.test(navigator.userAgent) ? "⌘" : "Ctrl") + "+C";
      return message.replace(/#{\s*key\s*}/g, copyKey);
    }
    function copy(text, options) {
      var debug, message, reselectPrevious, range, selection, mark, success = false;
      if (!options) {
        options = {};
      }
      debug = options.debug || false;
      try {
        reselectPrevious = deselectCurrent();
        range = document.createRange();
        selection = document.getSelection();
        mark = document.createElement("span");
        mark.textContent = text;
        mark.ariaHidden = "true";
        mark.style.all = "unset";
        mark.style.position = "fixed";
        mark.style.top = 0;
        mark.style.clip = "rect(0, 0, 0, 0)";
        mark.style.whiteSpace = "pre";
        mark.style.webkitUserSelect = "text";
        mark.style.MozUserSelect = "text";
        mark.style.msUserSelect = "text";
        mark.style.userSelect = "text";
        mark.addEventListener("copy", function(e) {
          e.stopPropagation();
          if (options.format) {
            e.preventDefault();
            if (typeof e.clipboardData === "undefined") {
              debug && console.warn("unable to use e.clipboardData");
              debug && console.warn("trying IE specific stuff");
              window.clipboardData.clearData();
              var format3 = clipboardToIE11Formatting[options.format] || clipboardToIE11Formatting["default"];
              window.clipboardData.setData(format3, text);
            } else {
              e.clipboardData.clearData();
              e.clipboardData.setData(options.format, text);
            }
          }
          if (options.onCopy) {
            e.preventDefault();
            options.onCopy(e.clipboardData);
          }
        });
        document.body.appendChild(mark);
        range.selectNodeContents(mark);
        selection.addRange(range);
        var successful = document.execCommand("copy");
        if (!successful) {
          throw new Error("copy command was unsuccessful");
        }
        success = true;
      } catch (err) {
        debug && console.error("unable to copy using execCommand: ", err);
        debug && console.warn("trying IE specific stuff");
        try {
          window.clipboardData.setData(options.format || "text", text);
          options.onCopy && options.onCopy(window.clipboardData);
          success = true;
        } catch (err2) {
          debug && console.error("unable to copy using clipboardData: ", err2);
          debug && console.error("falling back to prompt");
          message = format2("message" in options ? options.message : defaultMessage);
          window.prompt(message, text);
        }
      } finally {
        if (selection) {
          if (typeof selection.removeRange == "function") {
            selection.removeRange(range);
          } else {
            selection.removeAllRanges();
          }
        }
        if (mark) {
          document.body.removeChild(mark);
        }
        reselectPrevious();
      }
      return success;
    }
    module.exports = copy;
  }
});

// node_modules/react-copy-to-clipboard/lib/Component.js
var require_Component = __commonJS({
  "node_modules/react-copy-to-clipboard/lib/Component.js"(exports) {
    "use strict";
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.CopyToClipboard = void 0;
    var _react = _interopRequireDefault(require_react());
    var _copyToClipboard = _interopRequireDefault(require_copy_to_clipboard());
    var _excluded = ["text", "onCopy", "options", "children"];
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _objectWithoutProperties(source, excluded) {
      if (source == null)
        return {};
      var target = _objectWithoutPropertiesLoose(source, excluded);
      var key, i;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i = 0; i < sourceSymbolKeys.length; i++) {
          key = sourceSymbolKeys[i];
          if (excluded.indexOf(key) >= 0)
            continue;
          if (!Object.prototype.propertyIsEnumerable.call(source, key))
            continue;
          target[key] = source[key];
        }
      }
      return target;
    }
    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;
      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0)
          continue;
        target[key] = source[key];
      }
      return target;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      Object.defineProperty(subClass, "prototype", { writable: false });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return _assertThisInitialized(self);
    }
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var CopyToClipboard2 = function(_React$PureComponent) {
      _inherits(CopyToClipboard3, _React$PureComponent);
      var _super = _createSuper(CopyToClipboard3);
      function CopyToClipboard3() {
        var _this;
        _classCallCheck(this, CopyToClipboard3);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "onClick", function(event) {
          var _this$props = _this.props, text = _this$props.text, onCopy = _this$props.onCopy, children = _this$props.children, options = _this$props.options;
          var elem = _react["default"].Children.only(children);
          var result = (0, _copyToClipboard["default"])(text, options);
          if (onCopy) {
            onCopy(text, result);
          }
          if (elem && elem.props && typeof elem.props.onClick === "function") {
            elem.props.onClick(event);
          }
        });
        return _this;
      }
      _createClass(CopyToClipboard3, [{
        key: "render",
        value: function render() {
          var _this$props2 = this.props, _text = _this$props2.text, _onCopy = _this$props2.onCopy, _options = _this$props2.options, children = _this$props2.children, props = _objectWithoutProperties(_this$props2, _excluded);
          var elem = _react["default"].Children.only(children);
          return _react["default"].cloneElement(elem, _objectSpread(_objectSpread({}, props), {}, {
            onClick: this.onClick
          }));
        }
      }]);
      return CopyToClipboard3;
    }(_react["default"].PureComponent);
    exports.CopyToClipboard = CopyToClipboard2;
    _defineProperty(CopyToClipboard2, "defaultProps", {
      onCopy: void 0,
      options: void 0
    });
  }
});

// node_modules/react-copy-to-clipboard/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/react-copy-to-clipboard/lib/index.js"(exports, module) {
    "use strict";
    var _require = require_Component();
    var CopyToClipboard2 = _require.CopyToClipboard;
    CopyToClipboard2.CopyToClipboard = CopyToClipboard2;
    module.exports = CopyToClipboard2;
  }
});

// node_modules/sanity/lib/_chunks/desk-72f5b93a.js
var import_react = __toESM(require_react());
var import_jsx_runtime = __toESM(require_jsx_runtime());
var import_react_copy_to_clipboard = __toESM(require_lib2());
var import_isNumber = __toESM(require_isNumber());
var import_isString = __toESM(require_isString());
var import_omit = __toESM(require_omit());
var import_uniqBy = __toESM(require_uniqBy());
var import_negate = __toESM(require_negate());
var import_upperFirst = __toESM(require_upperFirst());
var import_is_hotkey = __toESM(require_lib());
var import_camelCase = __toESM(require_camelCase());
var import_speakingurl = __toESM(require_speakingurl());
var import_uniq = __toESM(require_uniq());
var import_kebabCase = __toESM(require_kebabCase());
var import_pickBy = __toESM(require_pickBy());
var import_find = __toESM(require_find());
var import_uniqueId = __toESM(require_uniqueId());
var import_react_is = __toESM(require_react_is());
var import_startCase = __toESM(require_startCase());
function Delay(_ref) {
  let {
    children,
    ms = 0
  } = _ref;
  const [ready, setReady] = (0, import_react.useState)(ms <= 0);
  (0, import_react.useEffect)(() => {
    if (ms <= 0) {
      return void 0;
    }
    const timeoutId = setTimeout(() => setReady(true), ms);
    return () => {
      clearTimeout(timeoutId);
    };
  }, [ms]);
  if (!ready || !children) {
    return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, {});
  }
  return typeof children === "function" ? children() : children;
}
function DocTitle(props) {
  const {
    document: documentValue
  } = props;
  const schema = useSchema();
  const schemaType = schema.get(documentValue._type);
  const {
    error,
    value
  } = useDocumentPreview({
    schemaType,
    value: documentValue
  });
  if (!schemaType) {
    return (0, import_jsx_runtime.jsxs)("code", {
      children: ["Unknown schema type: ", documentValue._type]
    });
  }
  if (error) {
    return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
      children: ["Error: ", error.message]
    });
  }
  return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, {
    children: (value == null ? void 0 : value.title) || (0, import_jsx_runtime.jsx)("span", {
      style: {
        color: "var(--card-muted-fg-color)"
      },
      children: "Untitled"
    })
  });
}
function TimeAgo(_ref2) {
  let {
    time
  } = _ref2;
  const timeAgo = useTimeAgo(time);
  return (0, import_jsx_runtime.jsxs)("span", {
    title: timeAgo,
    children: [timeAgo, " ago"]
  });
}
function isClientError(e) {
  if (typeof e !== "object")
    return false;
  if (!e)
    return false;
  return "statusCode" in e && "response" in e;
}
var POLL_INTERVAL = 5e3;
var visiblePoll$;
var getVisiblePoll$ = () => {
  if (!visiblePoll$) {
    visiblePoll$ = fromEvent(document, "visibilitychange").pipe(
      // add empty emission to have this fire on creation
      startWith(null),
      map(() => document.visibilityState === "visible"),
      distinctUntilChanged(),
      switchMap((visible) => visible ? (
        // using timer instead of interval since timer will emit on creation
        timer(0, POLL_INTERVAL)
      ) : EMPTY),
      shareReplay({
        refCount: true,
        bufferSize: 1
      })
    );
  }
  return visiblePoll$;
};
function getDocumentExistence(documentId, _ref3) {
  let {
    versionedClient
  } = _ref3;
  const draftId = getDraftId(documentId);
  const publishedId = getPublishedId(documentId);
  const requestOptions = {
    uri: versionedClient.getDataUrl("doc", "".concat(draftId, ",").concat(publishedId)),
    json: true,
    query: {
      excludeContent: "true"
    },
    tag: "use-referring-documents.document-existence"
  };
  return versionedClient.observable.request(requestOptions).pipe(map((_ref4) => {
    let {
      omitted
    } = _ref4;
    const nonExistant = omitted.filter((doc) => doc.reason === "existence");
    if (nonExistant.length === 2) {
      return void 0;
    }
    if (nonExistant.length === 0) {
      return publishedId;
    }
    return nonExistant.some((doc) => doc.id === draftId) ? publishedId : draftId;
  }));
}
function fetchCrossDatasetReferences(documentId, context) {
  const {
    versionedClient
  } = context;
  return getVisiblePoll$().pipe(switchMap(() => getDocumentExistence(documentId, context)), switchMap((checkDocumentId) => {
    if (!checkDocumentId) {
      return of({
        totalCount: 0,
        references: []
      });
    }
    const currentDataset = versionedClient.config().dataset;
    return versionedClient.observable.request({
      url: "/data/references/".concat(currentDataset, "/documents/").concat(checkDocumentId, "/to?excludeInternalReferences=true&excludePaths=true"),
      tag: "use-referring-documents.external"
    }).pipe(catchError((e) => {
      if (isClientError(e) && e.statusCode === 404) {
        return of({
          totalCount: 0,
          references: []
        });
      }
      throw e;
    }));
  }));
}
var useInternalReferences = createHookFromObservableFactory((_ref5) => {
  let [documentId, documentStore] = _ref5;
  const referencesClause = "*[references($documentId)][0...100]{_id,_type}";
  const totalClause = "count(*[references($documentId)])";
  const fetchQuery = '{"references":'.concat(referencesClause, ',"totalCount":').concat(totalClause, "}");
  const listenQuery = "*[references($documentId)]";
  return documentStore.listenQuery({
    fetch: fetchQuery,
    listen: listenQuery
  }, {
    documentId
  }, {
    tag: "use-referring-documents",
    transitions: ["appear", "disappear"],
    throttleTime: 5e3
  });
});
var useCrossDatasetReferences = createHookFromObservableFactory((_ref6) => {
  let [documentId, versionedClient] = _ref6;
  return getVisiblePoll$().pipe(switchMap(() => fetchCrossDatasetReferences(documentId, {
    versionedClient
  })));
});
function useReferringDocuments(documentId) {
  const versionedClient = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS);
  const documentStore = useDocumentStore();
  const publishedId = getPublishedId(documentId);
  const [internalReferences, isInternalReferencesLoading] = useInternalReferences((0, import_react.useMemo)(() => [publishedId, documentStore], [documentStore, publishedId]));
  const [crossDatasetReferences, isCrossDatasetReferencesLoading] = useCrossDatasetReferences((0, import_react.useMemo)(() => [publishedId, versionedClient], [publishedId, versionedClient]));
  const projectIds = (0, import_react.useMemo)(() => {
    return Array.from(new Set(crossDatasetReferences == null ? void 0 : crossDatasetReferences.references.map((crossDatasetReference) => crossDatasetReference.projectId).filter(Boolean))).sort();
  }, [crossDatasetReferences == null ? void 0 : crossDatasetReferences.references]);
  const datasetNames = (0, import_react.useMemo)(() => {
    return Array.from(new Set(crossDatasetReferences == null ? void 0 : crossDatasetReferences.references.map((crossDatasetReference) => (crossDatasetReference == null ? void 0 : crossDatasetReference.datasetName) || "").filter((datasetName) => Boolean(datasetName) && datasetName !== ""))).sort();
  }, [crossDatasetReferences == null ? void 0 : crossDatasetReferences.references]);
  const hasUnknownDatasetNames = (0, import_react.useMemo)(() => {
    return Boolean(crossDatasetReferences == null ? void 0 : crossDatasetReferences.references.some((crossDatasetReference) => typeof crossDatasetReference.datasetName !== "string"));
  }, [crossDatasetReferences == null ? void 0 : crossDatasetReferences.references]);
  return {
    totalCount: ((internalReferences == null ? void 0 : internalReferences.totalCount) || 0) + ((crossDatasetReferences == null ? void 0 : crossDatasetReferences.totalCount) || 0),
    projectIds,
    datasetNames,
    hasUnknownDatasetNames,
    internalReferences,
    crossDatasetReferences,
    isLoading: isInternalReferencesLoading || isCrossDatasetReferencesLoading
  };
}
function PublishedStatus(props) {
  const {
    document: document2
  } = props;
  const updatedAt = document2 && "_updatedAt" in document2 && document2._updatedAt;
  const statusLabel = document2 ? "Published" : "Not published";
  return (0, import_jsx_runtime.jsx)(Tooltip, {
    portal: true,
    content: (0, import_jsx_runtime.jsx)(Box, {
      padding: 2,
      children: (0, import_jsx_runtime.jsx)(Text, {
        size: 1,
        children: document2 ? (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
          children: ["Published ", updatedAt && (0, import_jsx_runtime.jsx)(TimeAgo, {
            time: updatedAt
          })]
        }) : (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, {
          children: "Not published"
        })
      })
    }),
    children: (0, import_jsx_runtime.jsx)(TextWithTone, {
      tone: "positive",
      dimmed: !document2,
      muted: !document2,
      size: 1,
      children: (0, import_jsx_runtime.jsx)(PublishIcon, {
        "aria-label": statusLabel
      })
    })
  });
}
function DraftStatus(props) {
  const {
    document: document2
  } = props;
  const updatedAt = document2 && "_updatedAt" in document2 && document2._updatedAt;
  return (0, import_jsx_runtime.jsx)(Tooltip, {
    portal: true,
    content: (0, import_jsx_runtime.jsx)(Box, {
      padding: 2,
      children: (0, import_jsx_runtime.jsx)(Text, {
        size: 1,
        children: document2 ? (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
          children: ["Edited ", updatedAt && (0, import_jsx_runtime.jsx)(TimeAgo, {
            time: updatedAt
          })]
        }) : (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, {
          children: "No unpublished edits"
        })
      })
    }),
    children: (0, import_jsx_runtime.jsx)(TextWithTone, {
      tone: "caution",
      dimmed: !document2,
      muted: !document2,
      size: 1,
      children: (0, import_jsx_runtime.jsx)(EditIcon, {})
    })
  });
}
function PaneItemPreview(props) {
  const {
    icon,
    layout,
    presence,
    schemaType,
    value
  } = props;
  const title = isRecord$2(value.title) && (0, import_react.isValidElement)(value.title) || (0, import_isString.default)(value.title) || (0, import_isNumber.default)(value.title) ? value.title : null;
  const {
    draft,
    published,
    isLoading
  } = useMemoObservable(() => getPreviewStateObservable(props.documentPreviewStore, schemaType, value._id, title), [props.documentPreviewStore, schemaType, value._id, title]);
  const status = isLoading ? null : (0, import_jsx_runtime.jsxs)(Inline, {
    space: 4,
    children: [presence && presence.length > 0 && (0, import_jsx_runtime.jsx)(DocumentPreviewPresence, {
      presence
    }), (0, import_jsx_runtime.jsx)(PublishedStatus, {
      document: published
    }), (0, import_jsx_runtime.jsx)(DraftStatus, {
      document: draft
    })]
  });
  return (0, import_jsx_runtime.jsx)(SanityDefaultPreview, {
    ...getPreviewValueWithFallback({
      value,
      draft,
      published
    }),
    isPlaceholder: isLoading,
    icon,
    layout,
    status
  });
}
function missingContext() {
  throw new Error("Pane is missing router context");
}
var PaneRouterContext = (0, import_react.createContext)({
  index: 0,
  groupIndex: 0,
  siblingIndex: 0,
  payload: void 0,
  params: {},
  hasGroupSiblings: false,
  groupLength: 0,
  routerPanesState: [],
  BackLink: () => missingContext(),
  ChildLink: () => missingContext(),
  ReferenceChildLink: () => missingContext(),
  handleEditReference: () => missingContext(),
  ParameterizedLink: () => missingContext(),
  replaceCurrent: () => missingContext(),
  closeCurrent: () => missingContext(),
  duplicateCurrent: () => missingContext(),
  setView: () => missingContext(),
  setParams: () => missingContext(),
  setPayload: () => missingContext(),
  navigateIntent: () => missingContext()
});
var BackLink = (0, import_react.forwardRef)(function BackLink2(props, ref) {
  const {
    routerPanesState,
    groupIndex
  } = (0, import_react.useContext)(PaneRouterContext);
  const panes = (0, import_react.useMemo)(() => routerPanesState.slice(0, groupIndex), [groupIndex, routerPanesState]);
  const state2 = (0, import_react.useMemo)(() => ({
    panes
  }), [panes]);
  return (0, import_jsx_runtime.jsx)(StateLink, {
    ...props,
    ref,
    state: state2
  });
});
var ChildLink = (0, import_react.forwardRef)(function ChildLink2(props, ref) {
  const {
    childId,
    childPayload,
    childParameters,
    ...rest
  } = props;
  const {
    routerPanesState,
    groupIndex
  } = (0, import_react.useContext)(PaneRouterContext);
  return (0, import_jsx_runtime.jsx)(StateLink, {
    ...rest,
    ref,
    state: {
      panes: [...routerPanesState.slice(0, groupIndex + 1), [{
        id: childId,
        params: childParameters,
        payload: childPayload
      }]]
    }
  });
});
var ReferenceChildLink = (0, import_react.forwardRef)(function ReferenceChildLink2(_ref7, ref) {
  let {
    documentId,
    documentType,
    parentRefPath,
    children,
    template,
    ...rest
  } = _ref7;
  return (0, import_jsx_runtime.jsx)(ChildLink, {
    ...rest,
    ref,
    childId: documentId,
    childPayload: template == null ? void 0 : template.params,
    childParameters: {
      type: documentType,
      parentRefPath: toString(parentRefPath),
      ...template && {
        template: template == null ? void 0 : template.id
      }
    },
    children
  });
});
var ParameterizedLink = (0, import_react.forwardRef)(function ParameterizedLink2(props, ref) {
  const {
    routerPanesState: currentPanes,
    groupIndex,
    siblingIndex
  } = (0, import_react.useContext)(PaneRouterContext);
  const {
    params,
    payload,
    ...rest
  } = props;
  const nextParams = useUnique(params);
  const nextPayload = useUnique(payload);
  const nextState = (0, import_react.useMemo)(() => {
    const currentGroup = currentPanes[groupIndex];
    const currentSibling = currentGroup[siblingIndex];
    const nextSibling = {
      ...currentSibling,
      params: nextParams != null ? nextParams : currentSibling.params,
      payload: nextPayload != null ? nextPayload : currentSibling.payload
    };
    const nextGroup = [...currentGroup.slice(0, siblingIndex), nextSibling, ...currentGroup.slice(siblingIndex + 1)];
    const nextPanes = [...currentPanes.slice(0, groupIndex), nextGroup, ...currentPanes.slice(groupIndex + 1)];
    return {
      panes: nextPanes
    };
  }, [currentPanes, groupIndex, nextParams, nextPayload, siblingIndex]);
  return (0, import_jsx_runtime.jsx)(StateLink, {
    ref,
    ...rest,
    state: nextState
  });
});
function usePaneRouter() {
  return (0, import_react.useContext)(PaneRouterContext);
}
var EMPTY_ARRAY = [];
function ReferencePreviewLink(props) {
  const {
    onClick,
    type,
    value
  } = props;
  const publishedId = getPublishedId(value == null ? void 0 : value._id);
  const documentPresence = useDocumentPresence(publishedId);
  const documentPreviewStore = useDocumentPreviewStore();
  const {
    ReferenceChildLink: ReferenceChildLink3
  } = usePaneRouter();
  const Link = (0, import_react.useCallback)(function LinkComponent(linkProps) {
    return (0, import_jsx_runtime.jsx)(ReferenceChildLink3, {
      documentId: value == null ? void 0 : value._id,
      documentType: type == null ? void 0 : type.name,
      parentRefPath: EMPTY_ARRAY,
      ...linkProps
    });
  }, [ReferenceChildLink3, type == null ? void 0 : type.name, value == null ? void 0 : value._id]);
  return (0, import_jsx_runtime.jsx)(PreviewCard$1, {
    __unstable_focusRing: true,
    as: Link,
    "data-as": "a",
    onClick,
    padding: 2,
    radius: 2,
    children: (0, import_jsx_runtime.jsx)(PaneItemPreview, {
      documentPreviewStore,
      icon: type == null ? void 0 : type.icon,
      layout: "default",
      presence: (documentPresence == null ? void 0 : documentPresence.length) > 0 ? documentPresence : EMPTY_ARRAY,
      schemaType: type,
      value
    })
  });
}
var __freeze$d = Object.freeze;
var __defProp$s = Object.defineProperty;
var __template$d = (cooked, raw) => __freeze$d(__defProp$s(cooked, "raw", {
  value: __freeze$d(raw || cooked.slice())
}));
var _a$d;
var _b$5;
var _c$3;
var _d$3;
var _e$2;
var ChevronWrapper = styled_components_browser_esm_default(Box)(_a$d || (_a$d = __template$d(["\n  margin-left: auto;\n"])));
var CrossDatasetReferencesDetails = styled_components_browser_esm_default.details(_b$5 || (_b$5 = __template$d(["\n  flex: none;\n\n  &[open] ", " {\n    transform: rotate(180deg);\n  }\n"])), ChevronWrapper);
var CrossDatasetReferencesSummary = styled_components_browser_esm_default.summary(_c$3 || (_c$3 = __template$d(["\n  list-style: none;\n\n  &::-webkit-details-marker {\n    display: none;\n  }\n"])));
var Table = styled_components_browser_esm_default.table(_d$3 || (_d$3 = __template$d(["\n  width: 100%;\n  text-align: left;\n  padding: 0 ", ";\n  border-collapse: collapse;\n\n  th {\n    padding: ", ";\n  }\n\n  td {\n    padding: 0 ", ";\n  }\n\n  tr > *:last-child {\n    text-align: right;\n  }\n"])), (_ref8) => {
  let {
    theme
  } = _ref8;
  return rem(theme.sanity.space[2]);
}, (_ref9) => {
  let {
    theme
  } = _ref9;
  return rem(theme.sanity.space[1]);
}, (_ref10) => {
  let {
    theme
  } = _ref10;
  return rem(theme.sanity.space[1]);
});
var DocumentIdFlex = styled_components_browser_esm_default(Flex)(_e$2 || (_e$2 = __template$d(["\n  min-height: 35px;\n"])));
var OtherReferenceCount = (props) => {
  const difference = props.totalCount - props.references.length;
  if (!difference)
    return null;
  return (0, import_jsx_runtime.jsxs)(Inline, {
    space: 2,
    children: [(0, import_jsx_runtime.jsxs)(Text, {
      size: 1,
      muted: true,
      children: [difference, " other reference", difference === 1 ? "" : "s", " not shown", " "]
    }), (0, import_jsx_runtime.jsx)(Tooltip, {
      portal: true,
      placement: "top",
      content: (0, import_jsx_runtime.jsx)(Container, {
        width: 0,
        children: (0, import_jsx_runtime.jsx)(Box, {
          padding: 2,
          children: (0, import_jsx_runtime.jsx)(Text, {
            size: 1,
            children: "We can't show metadata about these references because no token with access to the datasets they are in was found."
          })
        })
      }),
      children: (0, import_jsx_runtime.jsx)(Text, {
        size: 1,
        muted: true,
        children: (0, import_jsx_runtime.jsx)(InfoOutlineIcon, {})
      })
    })]
  });
};
function ConfirmDeleteDialogBody(_ref11) {
  let {
    crossDatasetReferences,
    internalReferences,
    documentTitle,
    totalCount,
    action,
    datasetNames,
    hasUnknownDatasetNames,
    onReferenceLinkClick
  } = _ref11;
  const schema = useSchema();
  const toast = useToast();
  const renderPreviewItem = (0, import_react.useCallback)((item) => {
    const type = schema.get(item._type);
    if (type) {
      return (0, import_jsx_runtime.jsx)(ReferencePreviewLink, {
        type,
        value: item,
        onClick: onReferenceLinkClick
      });
    }
    return (
      // Padding added to match the ReferencePreviewLink styling
      (0, import_jsx_runtime.jsx)(Box, {
        padding: 2,
        children: (0, import_jsx_runtime.jsx)(SanityDefaultPreview, {
          icon: UnknownIcon,
          title: "Preview Unavailable",
          subtitle: "ID: ".concat(item._id),
          layout: "default"
        })
      })
    );
  }, [schema, onReferenceLinkClick]);
  if ((internalReferences == null ? void 0 : internalReferences.totalCount) === 0 && (crossDatasetReferences == null ? void 0 : crossDatasetReferences.totalCount) === 0) {
    return (0, import_jsx_runtime.jsxs)(Text, {
      as: "p",
      children: ["Are you sure you want to ", action, " ", (0, import_jsx_runtime.jsxs)("strong", {
        children: ["“", documentTitle, "”"]
      }), "?"]
    });
  }
  const documentCount = crossDatasetReferences.totalCount === 1 ? "1 document" : "".concat(crossDatasetReferences.totalCount.toLocaleString(), " documents");
  const normalizedDatasetNames = [...datasetNames, ...hasUnknownDatasetNames ? ["unavailable"] : []];
  const datasetsCount = normalizedDatasetNames.length === 1 ? "another dataset" : "".concat(normalizedDatasetNames.length, " datasets");
  let datasetNameList = "Dataset".concat(normalizedDatasetNames.length === 1 ? "" : "s", ": ").concat(normalizedDatasetNames.join(", "));
  if (hasUnknownDatasetNames && normalizedDatasetNames.length === 1) {
    datasetNameList = "Unavailable dataset";
  }
  return (0, import_jsx_runtime.jsxs)(Card, {
    children: [(0, import_jsx_runtime.jsx)(Card, {
      padding: 3,
      radius: 2,
      tone: "caution",
      marginBottom: 4,
      flex: "none",
      children: (0, import_jsx_runtime.jsxs)(Flex, {
        children: [(0, import_jsx_runtime.jsx)(Text, {
          "aria-hidden": "true",
          size: 1,
          children: (0, import_jsx_runtime.jsx)(WarningOutlineIcon, {})
        }), (0, import_jsx_runtime.jsx)(Box, {
          flex: 1,
          marginLeft: 3,
          children: (0, import_jsx_runtime.jsx)(Text, {
            size: 1,
            children: totalCount === 1 ? (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
              children: ["1 document refers to “", documentTitle, "”"]
            }) : (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
              children: [totalCount.toLocaleString(), " documents refer to “", documentTitle, "”"]
            })
          })
        })]
      })
    }), (0, import_jsx_runtime.jsx)(Box, {
      flex: "none",
      marginBottom: 4,
      children: (0, import_jsx_runtime.jsxs)(Text, {
        children: ["You may not be able to ", action, " “", documentTitle, "” because the following documents refer to it:"]
      })
    }), (0, import_jsx_runtime.jsx)(Card, {
      radius: 2,
      shadow: 1,
      marginBottom: 4,
      flex: "auto",
      children: (0, import_jsx_runtime.jsxs)(Flex, {
        direction: "column",
        children: [internalReferences.totalCount > 0 && (0, import_jsx_runtime.jsxs)(Stack, {
          as: "ul",
          padding: 2,
          space: 3,
          "data-testid": "internal-references",
          children: [internalReferences == null ? void 0 : internalReferences.references.map((item) => (0, import_jsx_runtime.jsx)(Box, {
            as: "li",
            children: renderPreviewItem(item)
          }, item._id)), internalReferences.totalCount > internalReferences.references.length && (0, import_jsx_runtime.jsx)(Box, {
            as: "li",
            padding: 3,
            children: (0, import_jsx_runtime.jsx)(OtherReferenceCount, {
              ...internalReferences
            })
          })]
        }), crossDatasetReferences.totalCount > 0 && (0, import_jsx_runtime.jsxs)(CrossDatasetReferencesDetails, {
          "data-testid": "cross-dataset-references",
          style: {
            // only add the border if needed
            borderTop: internalReferences.totalCount > 0 ? "1px solid var(--card-shadow-outline-color)" : void 0
          },
          children: [(0, import_jsx_runtime.jsx)(CrossDatasetReferencesSummary, {
            children: (0, import_jsx_runtime.jsx)(Card, {
              as: "a",
              margin: 2,
              radius: 2,
              shadow: 1,
              paddingY: 1,
              children: (0, import_jsx_runtime.jsxs)(Flex, {
                align: "center",
                margin: 2,
                children: [(0, import_jsx_runtime.jsx)(Box, {
                  marginLeft: 3,
                  marginRight: 4,
                  children: (0, import_jsx_runtime.jsx)(Text, {
                    size: 3,
                    children: (0, import_jsx_runtime.jsx)(DocumentsIcon, {})
                  })
                }), (0, import_jsx_runtime.jsxs)(Flex, {
                  marginRight: 4,
                  direction: "column",
                  children: [(0, import_jsx_runtime.jsx)(Box, {
                    marginBottom: 2,
                    children: (0, import_jsx_runtime.jsxs)(Text, {
                      children: [documentCount, " in ", datasetsCount]
                    })
                  }), (0, import_jsx_runtime.jsx)(Box, {
                    children: (0, import_jsx_runtime.jsx)(Text, {
                      title: datasetNameList,
                      textOverflow: "ellipsis",
                      size: 1,
                      muted: true,
                      children: datasetNameList
                    })
                  })]
                }), (0, import_jsx_runtime.jsx)(ChevronWrapper, {
                  children: (0, import_jsx_runtime.jsx)(Text, {
                    muted: true,
                    children: (0, import_jsx_runtime.jsx)(ChevronDownIcon, {})
                  })
                })]
              })
            })
          }), (0, import_jsx_runtime.jsxs)(Box, {
            overflow: "auto",
            paddingBottom: 2,
            paddingX: 2,
            children: [(0, import_jsx_runtime.jsxs)(Table, {
              children: [(0, import_jsx_runtime.jsx)("thead", {
                children: (0, import_jsx_runtime.jsxs)("tr", {
                  children: [(0, import_jsx_runtime.jsx)("th", {
                    children: (0, import_jsx_runtime.jsx)(Label, {
                      muted: true,
                      size: 0,
                      style: {
                        minWidth: "5rem"
                      },
                      children: "Project ID"
                    })
                  }), (0, import_jsx_runtime.jsx)("th", {
                    children: (0, import_jsx_runtime.jsx)(Label, {
                      muted: true,
                      size: 0,
                      children: "Dataset"
                    })
                  }), (0, import_jsx_runtime.jsx)("th", {
                    children: (0, import_jsx_runtime.jsx)(Label, {
                      muted: true,
                      size: 0,
                      children: "Document ID"
                    })
                  })]
                })
              }), (0, import_jsx_runtime.jsx)("tbody", {
                children: crossDatasetReferences.references.filter((reference) => {
                  return "projectId" in reference;
                }).map((_ref12, index) => {
                  let {
                    projectId,
                    datasetName,
                    documentId
                  } = _ref12;
                  return (
                    // eslint-disable-next-line react/no-array-index-key
                    (0, import_jsx_runtime.jsxs)("tr", {
                      children: [(0, import_jsx_runtime.jsx)("td", {
                        children: (0, import_jsx_runtime.jsx)(Text, {
                          size: 1,
                          children: projectId
                        })
                      }), (0, import_jsx_runtime.jsx)("td", {
                        children: (0, import_jsx_runtime.jsx)(Text, {
                          size: 1,
                          children: datasetName || "unavailable"
                        })
                      }), (0, import_jsx_runtime.jsx)("td", {
                        children: (0, import_jsx_runtime.jsxs)(DocumentIdFlex, {
                          align: "center",
                          gap: 2,
                          justify: "flex-end",
                          children: [(0, import_jsx_runtime.jsx)(Text, {
                            textOverflow: "ellipsis",
                            size: 1,
                            children: documentId || "unavailable"
                          }), documentId && (0, import_jsx_runtime.jsx)(import_react_copy_to_clipboard.default, {
                            text: documentId,
                            onCopy: () => {
                              toast.push({
                                title: "Copied document ID to clipboard!",
                                status: "success"
                              });
                            },
                            children: (0, import_jsx_runtime.jsx)(Button, {
                              title: "Copy ID to clipboard",
                              mode: "bleed",
                              icon: ClipboardIcon,
                              fontSize: 0
                            })
                          })]
                        })
                      })]
                    }, "".concat(documentId, "-").concat(index))
                  );
                })
              })]
            }), (0, import_jsx_runtime.jsx)(Box, {
              padding: 2,
              children: (0, import_jsx_runtime.jsx)(OtherReferenceCount, {
                ...crossDatasetReferences
              })
            })]
          })]
        })]
      })
    }), (0, import_jsx_runtime.jsx)(Box, {
      flex: "none",
      children: (0, import_jsx_runtime.jsxs)(Text, {
        children: ["If you ", action, " this document, documents that refer to it will no longer be able to access it."]
      })
    })]
  });
}
var __freeze$c = Object.freeze;
var __defProp$r = Object.defineProperty;
var __template$c = (cooked, raw) => __freeze$c(__defProp$r(cooked, "raw", {
  value: __freeze$c(raw || cooked.slice())
}));
var _a$c;
var _b$4;
var DialogBody = styled_components_browser_esm_default(Box).attrs({
  padding: 4
})(_a$c || (_a$c = __template$c(["\n  box-sizing: border-box;\n"])));
var LoadingContainer = styled_components_browser_esm_default(Flex).attrs({
  align: "center",
  direction: "column",
  justify: "center"
})(_b$4 || (_b$4 = __template$c(["\n  height: 300px;\n"])));
function ConfirmDeleteDialog(_ref13) {
  let {
    id,
    type,
    action = "delete",
    onCancel,
    onConfirm
  } = _ref13;
  const dialogId = "deletion-confirmation-".concat((0, import_react.useId)());
  const {
    internalReferences,
    crossDatasetReferences,
    isLoading,
    totalCount,
    projectIds,
    datasetNames,
    hasUnknownDatasetNames
  } = useReferringDocuments(id);
  const capitalizedAction = "".concat(action.substring(0, 1).toUpperCase()).concat(action.substring(1));
  const documentTitle = (0, import_jsx_runtime.jsx)(DocTitle, {
    document: (0, import_react.useMemo)(() => ({
      _id: id,
      _type: type
    }), [id, type])
  });
  const showConfirmButton = !isLoading;
  return (0, import_jsx_runtime.jsx)(Dialog, {
    width: 1,
    id: dialogId,
    header: "".concat(capitalizedAction, " document?"),
    footer: (0, import_jsx_runtime.jsxs)(Grid, {
      columns: showConfirmButton ? 2 : 1,
      gap: 2,
      paddingX: 4,
      paddingY: 3,
      children: [(0, import_jsx_runtime.jsx)(Button, {
        mode: "ghost",
        onClick: onCancel,
        text: "Cancel"
      }), showConfirmButton && (0, import_jsx_runtime.jsx)(Button, {
        "data-testid": "confirm-delete-button",
        text: totalCount > 0 ? "".concat(capitalizedAction, " anyway") : "".concat(capitalizedAction, " now"),
        tone: "critical",
        onClick: onConfirm
      })]
    }),
    onClose: onCancel,
    onClickOutside: onCancel,
    children: (0, import_jsx_runtime.jsx)(DialogBody, {
      children: crossDatasetReferences && internalReferences && !isLoading ? (0, import_jsx_runtime.jsx)(ConfirmDeleteDialogBody, {
        crossDatasetReferences,
        internalReferences,
        documentTitle,
        isLoading,
        totalCount,
        action,
        projectIds,
        datasetNames,
        hasUnknownDatasetNames,
        onReferenceLinkClick: onCancel
      }) : (0, import_jsx_runtime.jsxs)(LoadingContainer, {
        "data-testid": "loading-container",
        children: [(0, import_jsx_runtime.jsx)(Spinner, {
          muted: true
        }), (0, import_jsx_runtime.jsx)(Box, {
          marginTop: 3,
          children: (0, import_jsx_runtime.jsx)(Text, {
            align: "center",
            muted: true,
            size: 1,
            children: "Looking for referring documents…"
          })
        })]
      })
    })
  });
}
function ConfirmDeleteDialogContainer(props) {
  const id = (0, import_react.useId)();
  const [error, setError] = (0, import_react.useState)(null);
  const handleRetry = (0, import_react.useCallback)(() => setError(null), []);
  return error ? (0, import_jsx_runtime.jsx)(Dialog, {
    id: "dialog-error-".concat(id),
    "data-testid": "confirm-delete-error-dialog",
    header: "Error",
    footer: (0, import_jsx_runtime.jsx)(Flex, {
      paddingX: 4,
      paddingY: 3,
      direction: "column",
      children: (0, import_jsx_runtime.jsx)(Button, {
        mode: "ghost",
        text: "Retry",
        onClick: handleRetry
      })
    }),
    onClose: props.onCancel,
    children: (0, import_jsx_runtime.jsx)(Box, {
      padding: 4,
      children: (0, import_jsx_runtime.jsx)(Text, {
        children: "An error occurred while loading referencing documents."
      })
    })
  }) : (0, import_jsx_runtime.jsx)(ErrorBoundary, {
    onCatch: setError,
    children: (0, import_jsx_runtime.jsx)(ConfirmDeleteDialog, {
      ...props
    })
  });
}
var MENU_GROUP_POPOVER_PROPS = {
  constrainSize: true,
  placement: "left-start",
  portal: true
};
function PaneMenuButtonItem(props) {
  const {
    disabled,
    isAfterGroup,
    node
  } = props;
  if (node.type === "divider") {
    return (0, import_jsx_runtime.jsx)(MenuDivider, {});
  }
  if (node.type === "group") {
    if (node.children.length === 0) {
      return null;
    }
    if (node.expanded) {
      return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
        children: [isAfterGroup && (0, import_jsx_runtime.jsx)(MenuDivider, {}), node.title && (0, import_jsx_runtime.jsx)(Box, {
          padding: 2,
          paddingBottom: 1,
          children: (0, import_jsx_runtime.jsx)(Label, {
            muted: true,
            size: 0,
            children: node.title
          })
        }), node.children.map((child, childIndex) => {
          var _a2;
          return (0, import_jsx_runtime.jsx)(PaneMenuButtonItem, {
            disabled: disabled || Boolean(node.disabled),
            isAfterGroup: ((_a2 = node.children[childIndex - 1]) == null ? void 0 : _a2.type) === "group",
            node: child
          }, child.key);
        })]
      });
    }
    return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
      children: [isAfterGroup && (0, import_jsx_runtime.jsx)(MenuDivider, {}), (0, import_jsx_runtime.jsx)(MenuGroup, {
        disabled,
        icon: node.icon,
        popover: MENU_GROUP_POPOVER_PROPS,
        text: node.title,
        children: node.children.map((child, childIndex) => {
          var _a2;
          return (0, import_jsx_runtime.jsx)(PaneMenuButtonItem, {
            disabled: disabled || Boolean(node.disabled),
            isAfterGroup: ((_a2 = node.children[childIndex - 1]) == null ? void 0 : _a2.type) === "group",
            node: child
          }, child.key);
        })
      })]
    });
  }
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
    children: [isAfterGroup && (0, import_jsx_runtime.jsx)(MenuDivider, {}), (0, import_jsx_runtime.jsx)(PaneContextMenuItemResolver, {
      disabled,
      node
    })]
  });
}
function PaneContextMenuItemResolver(props) {
  const {
    node
  } = props;
  if (node.intent) {
    return (0, import_jsx_runtime.jsx)(PaneContextIntentMenuItem, {
      ...props,
      intent: node.intent
    });
  }
  return (0, import_jsx_runtime.jsx)(PaneContextMenuItem, {
    ...props
  });
}
function PaneContextMenuItem(props) {
  var _a2;
  const {
    disabled,
    node
  } = props;
  const tooltipContent = typeof node.disabled === "object" && (0, import_jsx_runtime.jsx)(Text, {
    size: 1,
    children: node.disabled.reason
  });
  return (0, import_jsx_runtime.jsx)(TooltipOfDisabled, {
    content: tooltipContent,
    placement: "left",
    children: (0, import_jsx_runtime.jsx)(MenuItem, {
      disabled: disabled || Boolean(node.disabled),
      hotkeys: (_a2 = node.hotkey) == null ? void 0 : _a2.split("+"),
      icon: node.icon,
      iconRight: node.iconRight || node.selected && CheckmarkIcon,
      onClick: node.onAction,
      pressed: node.selected,
      text: node.title,
      tone: node.tone
    })
  });
}
function PaneContextIntentMenuItem(props) {
  var _a2;
  const {
    disabled,
    intent,
    node
  } = props;
  const tooltipContent = typeof node.disabled === "object" && (0, import_jsx_runtime.jsx)(Text, {
    size: 1,
    children: node.disabled.reason
  });
  const intentLink = useIntentLink({
    intent: intent.type,
    params: intent.params
  });
  const handleClick = (0, import_react.useCallback)((event) => {
    intentLink.onClick(event);
    node.onAction();
  }, [intentLink, node]);
  return (0, import_jsx_runtime.jsx)(TooltipOfDisabled, {
    content: tooltipContent,
    placement: "left",
    children: (0, import_jsx_runtime.jsx)(MenuItem, {
      as: "a",
      disabled: disabled || Boolean(node.disabled),
      hotkeys: (_a2 = node.hotkey) == null ? void 0 : _a2.split("+"),
      href: intentLink.href,
      icon: node.icon,
      iconRight: node.selected ? CheckmarkIcon : void 0,
      onClick: handleClick,
      pressed: node.selected,
      text: node.title,
      tone: node.tone
    })
  });
}
var CONTEXT_MENU_POPOVER_PROPS = {
  constrainSize: true,
  placement: "bottom",
  portal: true
};
function nodesHasTone(nodes, tone) {
  return nodes.some((node) => {
    return node.type === "item" && node.tone === tone || node.type === "group" && nodesHasTone(node.children, tone);
  });
}
function PaneContextMenuButton(props) {
  const {
    nodes
  } = props;
  const id = (0, import_react.useId)();
  const hasCritical = nodesHasTone(nodes, "critical");
  const hasCaution = nodesHasTone(nodes, "caution");
  return (0, import_jsx_runtime.jsx)(MenuButton, {
    button: (0, import_jsx_runtime.jsx)(StatusButton, {
      icon: EllipsisVerticalIcon,
      mode: "bleed",
      title: "Show menu",
      tone: hasCritical ? "critical" : hasCaution ? "caution" : void 0
    }),
    id,
    menu: (0, import_jsx_runtime.jsx)(Menu, {
      children: nodes.map((node, nodeIndex) => {
        var _a2;
        const isAfterGroup = ((_a2 = nodes[nodeIndex - 1]) == null ? void 0 : _a2.type) === "group";
        return (0, import_jsx_runtime.jsx)(PaneMenuButtonItem, {
          isAfterGroup,
          node
        }, node.key);
      })
    }),
    popover: CONTEXT_MENU_POPOVER_PROPS
  });
}
var PANE_DEBUG = false;
var PANE_COLLAPSED_WIDTH = 51;
var PANE_DEFAULT_MIN_WIDTH = PANE_COLLAPSED_WIDTH * 4;
var PaneContext = (0, import_react.createContext)(null);
var PaneLayoutContext = (0, import_react.createContext)(null);
function usePaneLayout() {
  const pane = (0, import_react.useContext)(PaneLayoutContext);
  if (!pane) {
    throw new Error("PaneLayout: missing context value");
  }
  return pane;
}
var __freeze$b = Object.freeze;
var __defProp$q = Object.defineProperty;
var __template$b = (cooked, raw) => __freeze$b(__defProp$q(cooked, "raw", {
  value: __freeze$b(raw || cooked.slice())
}));
var _a$b;
var Root$b = styled_components_browser_esm_default(Layer)(_a$b || (_a$b = __template$b(["\n  position: relative;\n  width: 1px;\n  min-width: 1px;\n\n  &:before {\n    content: '';\n    display: block;\n    position: absolute;\n    top: 0;\n    left: 0;\n    bottom: 0;\n    width: 1px;\n    background-color: var(--card-border-color);\n  }\n\n  &:not([data-disabled]) {\n    cursor: ew-resize;\n    width: 9px;\n    min-width: 9px;\n    margin: 0 -4px;\n\n    &:before {\n      left: 4px;\n    }\n\n    &:after {\n      content: '';\n      display: block;\n      position: absolute;\n      top: 0;\n      left: 0;\n      width: 9px;\n      bottom: 0;\n      background-color: var(--card-border-color);\n      opacity: 0;\n      transition: opacity 150ms;\n    }\n\n    &[data-dragging]:after,\n    &:hover:after {\n      opacity: 0.2;\n    }\n  }\n"])));
function PaneDivider(_ref14) {
  let {
    disabled,
    element
  } = _ref14;
  const {
    resize
  } = usePaneLayout();
  const [dragging, setDragging] = (0, import_react.useState)(false);
  const handleMouseDown = (0, import_react.useCallback)((event) => {
    if (!element)
      return;
    setDragging(true);
    event.preventDefault();
    const startX = event.pageX;
    resize("start", element, 0);
    const handleMouseMove = (e) => {
      e.preventDefault();
      const deltaX = e.pageX - startX;
      resize("move", element, deltaX);
    };
    const handleMouseUp = (e) => {
      e.preventDefault();
      setDragging(false);
      window.removeEventListener("mousemove", handleMouseMove);
      window.removeEventListener("mouseup", handleMouseUp);
      resize("end", element, 0);
    };
    window.addEventListener("mousemove", handleMouseMove);
    window.addEventListener("mouseup", handleMouseUp);
  }, [element, resize]);
  return (0, import_jsx_runtime.jsx)(Root$b, {
    "data-disabled": disabled ? "" : void 0,
    "data-dragging": dragging ? "" : void 0,
    onMouseDown: handleMouseDown
  });
}
var __freeze$a = Object.freeze;
var __defProp$p = Object.defineProperty;
var __template$a = (cooked, raw) => __freeze$a(__defProp$p(cooked, "raw", {
  value: __freeze$a(raw || cooked.slice())
}));
var _a$a;
var Root$a = styled_components_browser_esm_default(Card)(_a$a || (_a$a = __template$a(["\n  outline: none;\n\n  // NOTE: This will render a border to the right side of each pane\n  // without taking up physical space.\n  box-shadow: 1px 0 0 var(--card-border-color);\n"])));
var Pane = (0, import_react.forwardRef)(function Pane2(props, ref) {
  var _a2, _b2, _c2;
  const {
    children,
    currentMinWidth: currentMinWidthProp,
    currentMaxWidth: currentMaxWidthProp,
    flex: flexProp = 1,
    id,
    minWidth: minWidthProp,
    maxWidth: maxWidthProp,
    selected = false,
    ...restProps
  } = props;
  const [rootElement, setRootElement] = (0, import_react.useState)(null);
  const {
    collapse,
    collapsed: layoutCollapsed,
    expand,
    expandedElement,
    mount,
    panes
  } = usePaneLayout();
  const pane = panes.find((p) => p.element === rootElement);
  const paneIndex = pane && panes.indexOf(pane);
  const nextPane = typeof paneIndex === "number" ? panes[paneIndex + 1] : void 0;
  const isLast = paneIndex === panes.length - 1;
  const collapsed = layoutCollapsed ? false : (pane == null ? void 0 : pane.collapsed) || false;
  const nextCollapsed = (nextPane == null ? void 0 : nextPane.collapsed) || false;
  const forwardedRef = useForwardedRef(ref);
  const flex = (_a2 = pane == null ? void 0 : pane.flex) != null ? _a2 : flexProp;
  const currentMinWidth = (_b2 = pane == null ? void 0 : pane.currentMinWidth) != null ? _b2 : currentMinWidthProp;
  const currentMaxWidth = (_c2 = pane == null ? void 0 : pane.currentMaxWidth) != null ? _c2 : currentMaxWidthProp;
  const setRef = (0, import_react.useCallback)((refValue) => {
    setRootElement(refValue);
    forwardedRef.current = refValue;
  }, [forwardedRef]);
  (0, import_react.useEffect)(() => {
    if (!rootElement)
      return void 0;
    return mount(rootElement, {
      currentMinWidth: currentMinWidthProp,
      currentMaxWidth: currentMaxWidthProp,
      flex: flexProp,
      id,
      minWidth: minWidthProp,
      maxWidth: maxWidthProp
    });
  }, [currentMinWidthProp, currentMaxWidthProp, flexProp, id, minWidthProp, maxWidthProp, mount, rootElement]);
  const handleCollapse = (0, import_react.useCallback)(() => {
    if (!rootElement)
      return;
    collapse(rootElement);
  }, [collapse, rootElement]);
  const handleExpand = (0, import_react.useCallback)(() => {
    if (!rootElement)
      return;
    expand(rootElement);
  }, [expand, rootElement]);
  const contextValue = (0, import_react.useMemo)(() => ({
    collapse: handleCollapse,
    collapsed: layoutCollapsed ? false : collapsed,
    expand: handleExpand,
    index: paneIndex,
    isLast,
    rootElement
  }), [collapsed, handleCollapse, handleExpand, isLast, layoutCollapsed, paneIndex, rootElement]);
  const minWidth = (0, import_react.useMemo)(() => {
    if (layoutCollapsed) {
      return void 0;
    }
    if (collapsed)
      return PANE_COLLAPSED_WIDTH;
    if (currentMinWidth === 0) {
      return minWidthProp || PANE_DEFAULT_MIN_WIDTH;
    }
    if (isLast) {
      return minWidthProp || PANE_DEFAULT_MIN_WIDTH;
    }
    return currentMinWidth || minWidthProp || PANE_DEFAULT_MIN_WIDTH;
  }, [collapsed, currentMinWidth, isLast, layoutCollapsed, minWidthProp]);
  const maxWidth = (0, import_react.useMemo)(() => {
    if (collapsed)
      return PANE_COLLAPSED_WIDTH;
    if (layoutCollapsed && isLast) {
      return void 0;
    }
    if (isLast) {
      if (maxWidthProp) {
        return currentMaxWidth != null ? currentMaxWidth : maxWidthProp;
      }
      return void 0;
    }
    return currentMaxWidth != null ? currentMaxWidth : maxWidthProp;
  }, [collapsed, currentMaxWidth, isLast, layoutCollapsed, maxWidthProp]);
  const hidden = layoutCollapsed && !isLast;
  const divider = (0, import_react.useMemo)(() => !isLast && !layoutCollapsed && (0, import_jsx_runtime.jsx)(LegacyLayerProvider, {
    zOffset: "paneResizer",
    children: (0, import_jsx_runtime.jsx)(PaneDivider, {
      disabled: collapsed || nextCollapsed,
      element: rootElement
    })
  }), [collapsed, isLast, layoutCollapsed, nextCollapsed, rootElement]);
  const style = (0, import_react.useMemo)(() => ({
    flex,
    minWidth,
    maxWidth: maxWidth === Infinity ? void 0 : maxWidth
  }), [flex, minWidth, maxWidth]);
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
    children: [(0, import_jsx_runtime.jsx)(LegacyLayerProvider, {
      zOffset: "pane",
      children: (0, import_jsx_runtime.jsx)(PaneContext.Provider, {
        value: contextValue,
        children: (0, import_jsx_runtime.jsxs)(Root$a, {
          "data-testid": "pane",
          "data-ui": "Pane",
          tone: "inherit",
          hidden,
          id,
          overflow: layoutCollapsed ? void 0 : "hidden",
          ...restProps,
          "data-pane-collapsed": collapsed ? "" : void 0,
          "data-pane-index": paneIndex,
          "data-pane-selected": selected ? "" : void 0,
          ref: setRef,
          style,
          children: [PANE_DEBUG, (0, import_jsx_runtime.jsx)(BoundaryElementProvider, {
            element: rootElement,
            children: !hidden && (0, import_jsx_runtime.jsx)(Flex, {
              direction: "column",
              height: "fill",
              children
            })
          })]
        })
      })
    }), divider]
  });
});
function usePane() {
  const pane = (0, import_react.useContext)(PaneContext);
  if (!pane) {
    throw new Error("Pane: missing context value");
  }
  return pane;
}
var __freeze$9 = Object.freeze;
var __defProp$o = Object.defineProperty;
var __template$9 = (cooked, raw) => __freeze$9(__defProp$o(cooked, "raw", {
  value: __freeze$9(raw || cooked.slice())
}));
var _a$9;
var Root$9 = styled_components_browser_esm_default(Card)(_a$9 || (_a$9 = __template$9(["\n  position: relative;\n  outline: none;\n"])));
Root$9.displayName = "PaneContent__root";
var PaneContent = (0, import_react.forwardRef)(function PaneContent2(props, ref) {
  const {
    as,
    children,
    overflow,
    padding,
    ...restProps
  } = props;
  const {
    collapsed
  } = usePane();
  const {
    collapsed: layoutCollapsed
  } = usePaneLayout();
  return (0, import_jsx_runtime.jsx)(Root$9, {
    "data-testid": "pane-content",
    forwardedAs: as,
    ...restProps,
    flex: 1,
    hidden: collapsed,
    overflow: layoutCollapsed ? void 0 : overflow,
    padding,
    ref,
    tone: "inherit",
    children
  });
});
var __freeze$8 = Object.freeze;
var __defProp$n = Object.defineProperty;
var __template$8 = (cooked, raw) => __freeze$8(__defProp$n(cooked, "raw", {
  value: __freeze$8(raw || cooked.slice())
}));
var _a$8;
var _b$3;
var Root$8 = styled_components_browser_esm_default(Layer)(_a$8 || (_a$8 = __template$8(["\n  position: sticky;\n  bottom: 0;\n\n  &:before {\n    content: '';\n    display: block;\n    position: absolute;\n    left: 0;\n    right: 0;\n    top: -1px;\n    border-bottom: 1px solid var(--card-shadow-outline-color);\n  }\n"])));
var RootCard = styled_components_browser_esm_default(Card)(_b$3 || (_b$3 = __template$8(["\n  padding-bottom: env(safe-area-inset-bottom);\n"])));
var PaneFooter = (0, import_react.forwardRef)(function PaneFooter2(props, ref) {
  const {
    children,
    padding
  } = props;
  const {
    collapsed
  } = usePane();
  return (0, import_jsx_runtime.jsx)(LegacyLayerProvider, {
    zOffset: "paneFooter",
    children: (0, import_jsx_runtime.jsx)(Root$8, {
      "data-testid": "pane-footer",
      hidden: collapsed,
      ref,
      children: (0, import_jsx_runtime.jsx)(RootCard, {
        tone: "inherit",
        children: (0, import_jsx_runtime.jsx)(Box, {
          padding,
          children
        })
      })
    })
  });
});
var __freeze$7 = Object.freeze;
var __defProp$m = Object.defineProperty;
var __template$7 = (cooked, raw) => __freeze$7(__defProp$m(cooked, "raw", {
  value: __freeze$7(raw || cooked.slice())
}));
var _a$7;
var _b$2;
var _c$2;
var _d$2;
var _e$1;
var _f$1;
var Root$7 = styled_components_browser_esm_default(Layer)(_a$7 || (_a$7 = __template$7(["\n  line-height: 0;\n  position: sticky;\n  top: 0;\n\n  &:not([data-collapsed]):after {\n    content: '';\n    display: block;\n    position: absolute;\n    left: 0;\n    right: 0;\n    bottom: -1px;\n    border-bottom: 1px solid var(--card-shadow-outline-color);\n  }\n"])));
var Layout = styled_components_browser_esm_default(Flex)(_b$2 || (_b$2 = __template$7(["\n  transform-origin: calc(51px / 2);\n\n  [data-collapsed] > div > & {\n    transform: rotate(90deg);\n  }\n"])));
var TitleCard = styled_components_browser_esm_default(Card)((_ref15) => {
  let {
    theme
  } = _ref15;
  const {
    fg,
    bg
  } = theme.sanity.color.card.enabled;
  return Ae(_c$2 || (_c$2 = __template$7(["\n    background-color: ", ";\n\n    [data-ui='Text'] {\n      color: ", ";\n    }\n  "])), bg, fg);
});
var TitleTextSkeleton = styled_components_browser_esm_default(TextSkeleton)(_d$2 || (_d$2 = __template$7(["\n  width: 66%;\n  max-width: 175px;\n"])));
var TitleText = styled_components_browser_esm_default(Text)(_e$1 || (_e$1 = __template$7(["\n  cursor: default;\n  outline: none;\n"])));
var TabsBox = styled_components_browser_esm_default(Box)((_ref16) => {
  let {
    theme
  } = _ref16;
  const {
    color,
    space
  } = theme.sanity;
  return Ae(_f$1 || (_f$1 = __template$7(["\n    overflow: hidden;\n    overflow: clip;\n    position: relative;\n\n    & > div {\n      white-space: nowrap;\n      overflow: auto;\n      /* Hide scrollbars */\n      scrollbar-width: none;\n      &::-webkit-scrollbar {\n        width: 0;\n        height: 0;\n      }\n    }\n\n    /* right padding */\n    & > div:after {\n      content: '';\n      display: inline-block;\n      top: 0;\n      right: 0;\n      bottom: 0;\n      width: ", "px;\n      height: 1px;\n    }\n\n    /* Gradient that makes it look like tabs disappear into nothing (looks nicer) */\n    &:after {\n      content: '';\n      display: block;\n      position: absolute;\n      top: 0;\n      right: 0;\n      bottom: 0;\n      background: linear-gradient(to right, ", ", var(--card-bg-color));\n      width: ", "px;\n      pointer-events: none;\n    }\n  "])), space[3], rgba(color.base.bg, 0), space[3]);
});
var PaneHeader = (0, import_react.forwardRef)(function PaneHeader2(props, ref) {
  const {
    actions,
    backButton,
    contentAfter,
    loading,
    subActions,
    tabs,
    tabIndex,
    title
  } = props;
  const {
    collapse,
    collapsed,
    expand,
    rootElement: paneElement
  } = usePane();
  const paneRect = useElementRect(paneElement || null);
  const layoutStyle = (0, import_react.useMemo)(() => ({
    width: collapsed ? (paneRect == null ? void 0 : paneRect.height) || window.innerHeight : void 0
  }), [collapsed, paneRect]);
  const handleTitleClick = (0, import_react.useCallback)(() => {
    if (collapsed)
      return;
    collapse();
  }, [collapse, collapsed]);
  const handleLayoutClick = (0, import_react.useCallback)(() => {
    if (!collapsed)
      return;
    expand();
  }, [collapsed, expand]);
  const showTabsOrSubActions = Boolean(!collapsed && (tabs || subActions));
  return (0, import_jsx_runtime.jsx)(LayerProvider, {
    zOffset: 100,
    children: (0, import_jsx_runtime.jsx)(Root$7, {
      "data-collapsed": collapsed ? "" : void 0,
      "data-testid": "pane-header",
      ref,
      children: (0, import_jsx_runtime.jsx)(LegacyLayerProvider, {
        zOffset: "paneHeader",
        children: (0, import_jsx_runtime.jsxs)(Card, {
          "data-collapsed": collapsed ? "" : void 0,
          tone: "inherit",
          children: [(0, import_jsx_runtime.jsxs)(Layout, {
            onClick: handleLayoutClick,
            padding: 2,
            sizing: "border",
            style: layoutStyle,
            children: [backButton && (0, import_jsx_runtime.jsx)(Box, {
              flex: "none",
              padding: 1,
              children: backButton
            }), (0, import_jsx_runtime.jsxs)(TitleCard, {
              __unstable_focusRing: true,
              flex: 1,
              forwardedAs: "button",
              marginRight: actions ? 1 : 0,
              onClick: handleTitleClick,
              paddingLeft: backButton ? 1 : 3,
              paddingY: 3,
              tabIndex,
              children: [loading && (0, import_jsx_runtime.jsx)(TitleTextSkeleton, {
                animated: true,
                radius: 1
              }), !loading && (0, import_jsx_runtime.jsx)(TitleText, {
                textOverflow: "ellipsis",
                weight: "semibold",
                children: title
              })]
            }), actions && (0, import_jsx_runtime.jsx)(Box, {
              flex: "none",
              hidden: collapsed,
              children: (0, import_jsx_runtime.jsx)(LegacyLayerProvider, {
                zOffset: "paneHeader",
                children: actions
              })
            })]
          }), showTabsOrSubActions && (0, import_jsx_runtime.jsxs)(Flex, {
            align: "center",
            hidden: collapsed,
            overflow: "auto",
            paddingBottom: 3,
            paddingX: 3,
            paddingTop: 1,
            children: [(0, import_jsx_runtime.jsx)(TabsBox, {
              flex: 1,
              marginRight: subActions ? 3 : 0,
              children: tabs
            }), subActions && subActions]
          }), !collapsed && contentAfter && contentAfter]
        })
      })
    })
  });
});
function PaneHeaderActionButton(props) {
  const {
    node,
    padding
  } = props;
  if (node.type === "item") {
    return (0, import_jsx_runtime.jsx)(PaneHeaderMenuItemActionButton, {
      node,
      padding
    });
  }
  if (node.type === "group") {
    return (0, import_jsx_runtime.jsx)(PaneHeaderMenuGroupActionButton, {
      node,
      padding
    });
  }
  console.warn('unknown menu node (expected `type: "item" | "group"`):', node);
  return null;
}
function PaneHeaderMenuItemActionButton(props) {
  var _a2;
  const {
    node,
    padding
  } = props;
  if (node.intent) {
    return (0, import_jsx_runtime.jsx)(PaneHeaderActionIntentButton, {
      ...props,
      intent: node.intent
    });
  }
  const disabledTooltipContent = typeof node.disabled === "object" && (0, import_jsx_runtime.jsx)(Text, {
    size: 1,
    children: node.disabled.reason
  });
  return (0, import_jsx_runtime.jsx)(TooltipOfDisabled, {
    content: disabledTooltipContent,
    placement: "bottom",
    children: (0, import_jsx_runtime.jsx)(StatusButton, {
      disabled: Boolean(node.disabled),
      hotkey: (_a2 = node.hotkey) == null ? void 0 : _a2.split("+"),
      icon: node.icon,
      label: disabledTooltipContent ? void 0 : node.title,
      onClick: node.onAction,
      padding,
      selected: node.selected,
      tone: node.tone
    })
  });
}
function PaneHeaderActionIntentButton(props) {
  var _a2;
  const {
    intent,
    node,
    padding
  } = props;
  const disabledTooltipContent = typeof node.disabled === "object" && (0, import_jsx_runtime.jsx)(Text, {
    size: 1,
    children: node.disabled.reason
  });
  const intentLink = useIntentLink({
    intent: intent.type,
    params: intent.params
  });
  const handleClick = (0, import_react.useCallback)((event) => {
    intentLink.onClick(event);
    node.onAction();
  }, [intentLink, node]);
  return (0, import_jsx_runtime.jsx)(TooltipOfDisabled, {
    content: disabledTooltipContent,
    placement: "bottom",
    children: (0, import_jsx_runtime.jsx)(StatusButton, {
      as: "a",
      disabled: Boolean(node.disabled),
      hotkey: (_a2 = node.hotkey) == null ? void 0 : _a2.split("+"),
      href: intentLink.href,
      icon: node.icon,
      label: disabledTooltipContent ? void 0 : node.title,
      onClick: handleClick,
      padding,
      selected: node.selected,
      tone: node.tone
    })
  });
}
function PaneHeaderMenuGroupActionButton(props) {
  var _a2;
  const {
    node,
    padding
  } = props;
  return (0, import_jsx_runtime.jsx)(MenuButton, {
    button: (0, import_jsx_runtime.jsx)(StatusButton, {
      disabled: node.disabled,
      icon: (_a2 = node.icon) != null ? _a2 : UnknownIcon,
      label: node.title,
      padding
    }),
    id: (0, import_react.useId)(),
    menu: (0, import_jsx_runtime.jsx)(Menu, {
      children: node.children.map((child, idx) => {
        var _a22;
        return (0, import_jsx_runtime.jsx)(PaneMenuButtonItem, {
          disabled: Boolean(node.disabled),
          isAfterGroup: ((_a22 = node.children[idx - 1]) == null ? void 0 : _a22.type) === "group",
          node: child
        }, child.key);
      })
    })
  });
}
var __freeze$6 = Object.freeze;
var __defProp$l = Object.defineProperty;
var __template$6 = (cooked, raw) => __freeze$6(__defProp$l(cooked, "raw", {
  value: __freeze$6(raw || cooked.slice())
}));
var _a$6;
var Root$6 = styled_components_browser_esm_default(Card)(_a$6 || (_a$6 = __template$6(["\n  transition: opacity 200ms;\n  position: relative;\n  z-index: 1;\n  padding-left: env(safe-area-inset-left);\n  padding-right: env(safe-area-inset-right);\n  opacity: 0;\n\n  &:not([hidden]) {\n    display: flex;\n  }\n\n  &:not([data-collapsed]) {\n    overflow: auto;\n  }\n\n  &[data-mounted] {\n    opacity: 1;\n  }\n\n  &[data-resizing] {\n    pointer-events: none;\n  }\n"])));
function isMenuNodeButton(node) {
  return (node.type === "item" || node.type === "group") && node.renderAsButton;
}
var isNotMenuNodeButton = (0, import_negate.default)(isMenuNodeButton);
function resolveMenuNodes(params) {
  var _a2, _b2;
  const {
    fieldActions = [],
    menuItems,
    menuItemGroups
  } = params;
  const nodes = [];
  let keyOffset = 0;
  for (let i = 0; i < fieldActions.length; i += 1) {
    const a = fieldActions[i];
    nodes.push(mapFieldActionToPaneMenuNode(a, "".concat(i, "-").concat(a.type)));
  }
  keyOffset += nodes.length;
  const groups = [];
  for (const itemGroup of menuItemGroups) {
    const group = groups.find((g) => g.key === itemGroup.id);
    if (!group) {
      groups.push({
        type: "group",
        key: itemGroup.id,
        children: [],
        expanded: true,
        renderAsButton: false,
        title: itemGroup.title
      });
    }
  }
  const ungroupedItems = [];
  for (let i = 0; i < menuItems.length; i += 1) {
    const item = menuItems[i];
    let group = item.group && groups.find((g) => g.key === item.group);
    if (item.group && !group) {
      group = {
        type: "group",
        key: item.group,
        expanded: true,
        icon: item.icon,
        title: item.group,
        children: [],
        renderAsButton: false
      };
      groups.push(group);
    }
    if (group) {
      group.children.push({
        type: "item",
        key: "".concat(keyOffset + i, "-item"),
        hotkey: item.shortcut,
        icon: item.icon,
        onAction: () => params.actionHandler(item),
        renderAsButton: (_a2 = item.showAsAction) != null ? _a2 : false,
        selected: item.selected,
        title: item.title,
        tone: item.tone
      });
    } else {
      ungroupedItems.push({
        type: "item",
        key: "".concat(keyOffset + i, "-item"),
        hotkey: item.shortcut,
        icon: item.icon,
        onAction: () => params.actionHandler(item),
        renderAsButton: (_b2 = item.showAsAction) != null ? _b2 : false,
        selected: item.selected,
        title: item.title,
        tone: item.tone
      });
    }
  }
  return [...ungroupedItems, ...groups, ...nodes];
}
function mapFieldActionToPaneMenuNode(a, key) {
  var _a2, _b2, _c2;
  if (a.type === "divider") {
    return {
      type: "divider",
      key
    };
  }
  if (a.type === "group") {
    return {
      type: "group",
      key,
      children: a.children.map((child, childIdx) => mapFieldActionToPaneMenuNode(child, "".concat(key, "-").concat(childIdx, "-").concat(child.type))),
      disabled: a.disabled,
      expanded: (_a2 = a.expanded) != null ? _a2 : true,
      icon: a.icon,
      title: a.title,
      renderAsButton: (_b2 = a.renderAsButton) != null ? _b2 : false
    };
  }
  return {
    type: "item",
    key,
    disabled: a.disabled,
    icon: a.icon,
    iconRight: a.iconRight,
    onAction: a.onAction,
    renderAsButton: (_c2 = a.renderAsButton) != null ? _c2 : false,
    selected: a.selected,
    title: a.title,
    tone: a.tone
  };
}
var IntentButton = (0, import_react.forwardRef)(function IntentButton2(props, ref) {
  const {
    intent,
    ...restProps
  } = props;
  const Link = (0, import_react.useMemo)(() => (
    // eslint-disable-next-line @typescript-eslint/no-shadow
    (0, import_react.forwardRef)(function Link2(linkProps, linkRef) {
      return (0, import_jsx_runtime.jsx)(IntentLink, {
        ...linkProps,
        intent: intent.type,
        params: intent.params,
        ref: linkRef
      });
    })
  ), [intent]);
  return props.disabled ? (0, import_jsx_runtime.jsx)(Button, {
    ...props,
    as: "a",
    role: "link",
    "aria-disabled": "true"
  }) : (0, import_jsx_runtime.jsx)(Button, {
    ...restProps,
    as: Link,
    "data-as": "a",
    ref
  });
});
function InsufficientPermissionsMessageTooltip(_ref17) {
  let {
    reveal,
    loading,
    children
  } = _ref17;
  const currentUser = useCurrentUser();
  if (!reveal) {
    return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, {
      children
    });
  }
  return (0, import_jsx_runtime.jsx)(Tooltip, {
    content: loading ? (0, import_jsx_runtime.jsx)(Box, {
      padding: 2,
      children: (0, import_jsx_runtime.jsx)(Text, {
        children: "Loading…"
      })
    }) : (0, import_jsx_runtime.jsx)(InsufficientPermissionsMessage, {
      currentUser
    }),
    portal: true,
    children: (0, import_jsx_runtime.jsx)("div", {
      children
    })
  });
}
var POPOVER_PROPS = {
  constrainSize: true,
  placement: "bottom",
  portal: true
};
var getIntent = (schema, templates, item) => {
  var _a2;
  const typeName = (_a2 = templates.find((t) => t.id === item.templateId)) == null ? void 0 : _a2.schemaType;
  if (!typeName)
    return null;
  const baseParams = {
    template: item.templateId,
    type: typeName,
    id: item.initialDocumentId
  };
  return {
    type: "create",
    params: item.parameters ? [baseParams, item.parameters] : baseParams
  };
};
function PaneHeaderCreateButton(_ref18) {
  let {
    templateItems
  } = _ref18;
  const schema = useSchema();
  const templates = useTemplates();
  const [templatePermissions, isTemplatePermissionsLoading] = useTemplatePermissions({
    templateItems
  });
  const nothingGranted = (0, import_react.useMemo)(() => {
    return !isTemplatePermissionsLoading && (templatePermissions == null ? void 0 : templatePermissions.every((permission) => !permission.granted));
  }, [isTemplatePermissionsLoading, templatePermissions]);
  const permissionsById = (0, import_react.useMemo)(() => {
    if (!templatePermissions)
      return {};
    return templatePermissions.reduce((acc, permission) => {
      acc[permission.id] = permission;
      return acc;
    }, {});
  }, [templatePermissions]);
  if (nothingGranted) {
    return (0, import_jsx_runtime.jsx)(InsufficientPermissionsMessageTooltip, {
      reveal: true,
      loading: isTemplatePermissionsLoading,
      children: (0, import_jsx_runtime.jsx)(Button, {
        "aria-label": "Insufficient permissions",
        icon: ComposeIcon,
        mode: "bleed",
        disabled: true,
        "data-testid": "action-intent-button"
      })
    });
  }
  if (templateItems.length === 1) {
    const firstItem = templateItems[0];
    const permissions = permissionsById[firstItem.id];
    const disabled = !(permissions == null ? void 0 : permissions.granted);
    const intent = getIntent(schema, templates, firstItem);
    if (!intent)
      return null;
    return (0, import_jsx_runtime.jsx)(InsufficientPermissionsMessageTooltip, {
      reveal: disabled,
      loading: isTemplatePermissionsLoading,
      children: (0, import_jsx_runtime.jsx)(IntentButton, {
        "aria-label": firstItem.title,
        icon: firstItem.icon || ComposeIcon,
        intent,
        mode: "bleed",
        disabled,
        "data-testid": "action-intent-button"
      })
    });
  }
  return (0, import_jsx_runtime.jsx)(MenuButton, {
    button: (0, import_jsx_runtime.jsx)(Button, {
      icon: ComposeIcon,
      mode: "bleed",
      "data-testid": "multi-action-intent-button"
    }),
    id: "create-menu",
    menu: (0, import_jsx_runtime.jsxs)(Menu, {
      children: [(0, import_jsx_runtime.jsx)(Box, {
        paddingX: 3,
        paddingTop: 3,
        paddingBottom: 2,
        children: (0, import_jsx_runtime.jsx)(Label, {
          muted: true,
          children: "Create"
        })
      }), templateItems.map((item, itemIndex) => {
        const permissions = permissionsById[item.id];
        const disabled = !(permissions == null ? void 0 : permissions.granted);
        const intent = getIntent(schema, templates, item);
        const template = templates.find((t) => t.id === item.templateId);
        if (!template || !intent)
          return null;
        const Link = (0, import_react.forwardRef)((linkProps, linkRef) => disabled ? (0, import_jsx_runtime.jsx)("button", {
          type: "button",
          disabled: true,
          ...linkProps,
          ref: linkRef
        }) : (0, import_jsx_runtime.jsx)(IntentLink, {
          ...linkProps,
          intent: intent.type,
          params: intent.params,
          ref: linkRef
        }));
        Link.displayName = "Link";
        return (0, import_jsx_runtime.jsx)(InsufficientPermissionsMessageTooltip, {
          reveal: disabled,
          loading: isTemplatePermissionsLoading,
          children: (0, import_jsx_runtime.jsx)(MenuItem, {
            as: Link,
            "data-as": disabled ? "button" : "a",
            text: item.title || template.title,
            "aria-label": disabled ? "Insufficient permissions" : item.title || template.title,
            disabled,
            "data-testid": "action-intent-button-".concat(itemIndex)
          })
        }, item.id);
      })]
    }),
    popover: POPOVER_PROPS
  });
}
function isNonNullable(value) {
  return value !== null && value !== void 0;
}
var hashObject = (value) => {
  const sortObject = (v) => {
    if (typeof v !== "object" || !v)
      return v;
    if (Array.isArray(v))
      return v.map(sortObject);
    return Object.entries(v).sort((_ref19, _ref20) => {
      let [keyA] = _ref19;
      let [keyB] = _ref20;
      return keyA.localeCompare(keyB, "en");
    });
  };
  const normalize = (v) => JSON.parse(JSON.stringify(v));
  return JSON.stringify(sortObject(normalize(value)));
};
var PaneHeaderActions = (0, import_react.memo)(function PaneHeaderActions2(props) {
  const {
    initialValueTemplateItems: initialValueTemplateItemsFromStructure = EMPTY_ARRAY$7,
    menuItems = EMPTY_ARRAY$7,
    menuItemGroups = EMPTY_ARRAY$7,
    actionHandlers = EMPTY_OBJECT
  } = props;
  const templates = useTemplates();
  const handleAction = (0, import_react.useCallback)((item) => {
    if (typeof item.action === "string" && !(item.action in actionHandlers)) {
      console.warn("No handler for action:", item.action);
      return false;
    }
    const handler = (
      // eslint-disable-next-line no-nested-ternary
      typeof item.action === "function" ? item.action : typeof item.action === "string" ? actionHandlers[item.action] : null
    );
    if (handler) {
      handler(item.params);
      return true;
    }
    return false;
  }, [actionHandlers]);
  const menuNodes = (0, import_react.useMemo)(() => resolveMenuNodes({
    actionHandler: handleAction,
    menuItemGroups,
    menuItems: menuItems.filter((item) => {
      var _a2;
      return ((_a2 = item.intent) == null ? void 0 : _a2.type) !== "create";
    })
  }), [handleAction, menuItemGroups, menuItems]);
  const actionNodes = (0, import_react.useMemo)(() => menuNodes.filter(isMenuNodeButton), [menuNodes]);
  const contextMenuNodes = (0, import_react.useMemo)(() => menuNodes.filter(isNotMenuNodeButton), [menuNodes]);
  const initialValueTemplateItemFromMenuItems = (0, import_react.useMemo)(() => {
    return menuItems.map((item, menuItemIndex) => {
      var _a2;
      if (((_a2 = item.intent) == null ? void 0 : _a2.type) !== "create")
        return null;
      const {
        params
      } = item.intent;
      if (!params)
        return null;
      const intentParams = Array.isArray(params) ? params[0] : params;
      const templateParams = Array.isArray(params) ? params[1] : void 0;
      const templateId = intentParams.template || intentParams.type;
      if (!templateId)
        return null;
      const template = templates.find((t) => t.id === templateId);
      if (!template)
        return null;
      const initialDocumentId = intentParams.id;
      return {
        item,
        template,
        templateParams,
        menuItemIndex,
        initialDocumentId
      };
    }).filter(isNonNullable).map((_ref21) => {
      let {
        initialDocumentId,
        item,
        template,
        menuItemIndex,
        templateParams
      } = _ref21;
      const initialValueTemplateItem = {
        id: "menuItem".concat(menuItemIndex),
        initialDocumentId,
        templateId: template.id,
        type: "initialValueTemplateItem",
        title: item.title || template.title,
        icon: item.icon,
        description: template.description,
        parameters: templateParams,
        schemaType: template.schemaType
      };
      return initialValueTemplateItem;
    });
  }, [menuItems, templates]);
  const combinedInitialValueTemplates = (0, import_react.useMemo)(() => {
    return (0, import_uniqBy.default)([...initialValueTemplateItemFromMenuItems, ...initialValueTemplateItemsFromStructure], (item) => hashObject([item.initialDocumentId, item.templateId, item.parameters]));
  }, [initialValueTemplateItemFromMenuItems, initialValueTemplateItemsFromStructure]);
  return (0, import_jsx_runtime.jsxs)(Flex, {
    gap: 1,
    children: [combinedInitialValueTemplates.length > 0 && (0, import_jsx_runtime.jsx)(PaneHeaderCreateButton, {
      templateItems: combinedInitialValueTemplates
    }), actionNodes.map((node) => (0, import_jsx_runtime.jsx)(PaneHeaderActionButton, {
      node
    }, node.key)), contextMenuNodes.length > 0 && (0, import_jsx_runtime.jsx)(PaneContextMenuButton, {
      nodes: contextMenuNodes
    })]
  });
});
var DISABLED_REASON_TITLE$4 = {
  NOTHING_TO_DELETE: "This document doesn’t yet exist or is already deleted"
};
var DeleteAction = (_ref22) => {
  let {
    id,
    type,
    draft,
    onComplete
  } = _ref22;
  const {
    delete: deleteOp
  } = useDocumentOperation(id, type);
  const [isDeleting, setIsDeleting] = (0, import_react.useState)(false);
  const [isConfirmDialogOpen, setConfirmDialogOpen] = (0, import_react.useState)(false);
  const handleCancel = (0, import_react.useCallback)(() => {
    setConfirmDialogOpen(false);
    onComplete();
  }, [onComplete]);
  const handleConfirm = (0, import_react.useCallback)(() => {
    setIsDeleting(true);
    setConfirmDialogOpen(false);
    deleteOp.execute();
    onComplete();
  }, [deleteOp, onComplete]);
  const handle = (0, import_react.useCallback)(() => {
    setConfirmDialogOpen(true);
  }, []);
  const [permissions, isPermissionsLoading] = useDocumentPairPermissions({
    id,
    type,
    permission: "delete"
  });
  const currentUser = useCurrentUser();
  if (!isPermissionsLoading && !(permissions == null ? void 0 : permissions.granted)) {
    return {
      tone: "critical",
      icon: TrashIcon,
      disabled: true,
      label: "Delete",
      title: (0, import_jsx_runtime.jsx)(InsufficientPermissionsMessage, {
        operationLabel: "delete this document",
        currentUser
      })
    };
  }
  return {
    tone: "critical",
    icon: TrashIcon,
    disabled: isDeleting || Boolean(deleteOp.disabled) || isPermissionsLoading,
    title: deleteOp.disabled && DISABLED_REASON_TITLE$4[deleteOp.disabled] || "",
    label: isDeleting ? "Deleting…" : "Delete",
    shortcut: "Ctrl+Alt+D",
    onHandle: handle,
    dialog: isConfirmDialogOpen && {
      type: "custom",
      component: (0, import_jsx_runtime.jsx)(ConfirmDeleteDialogContainer, {
        action: "delete",
        id: (draft == null ? void 0 : draft._id) || id,
        type,
        onCancel: handleCancel,
        onConfirm: handleConfirm
      })
    }
  };
};
DeleteAction.action = "delete";
var DISABLED_REASON_TITLE$3 = {
  NO_CHANGES: "This document has no unpublished changes",
  NOT_PUBLISHED: "This document is not published"
};
var DiscardChangesAction = (_ref23) => {
  let {
    id,
    type,
    published,
    liveEdit,
    onComplete
  } = _ref23;
  const {
    discardChanges
  } = useDocumentOperation(id, type);
  const [isConfirmDialogOpen, setConfirmDialogOpen] = (0, import_react.useState)(false);
  const [permissions, isPermissionsLoading] = useDocumentPairPermissions({
    id,
    type,
    permission: "discardDraft"
  });
  const currentUser = useCurrentUser();
  const handleConfirm = (0, import_react.useCallback)(() => {
    discardChanges.execute();
    onComplete();
  }, [discardChanges, onComplete]);
  const handle = (0, import_react.useCallback)(() => {
    setConfirmDialogOpen(true);
  }, []);
  const dialog = (0, import_react.useMemo)(() => isConfirmDialogOpen && {
    type: "confirm",
    tone: "critical",
    onCancel: onComplete,
    onConfirm: handleConfirm,
    message: (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, {
      children: "Are you sure you want to discard all changes since last published?"
    })
  }, [handleConfirm, isConfirmDialogOpen, onComplete]);
  if (!published || liveEdit) {
    return null;
  }
  if (!isPermissionsLoading && !(permissions == null ? void 0 : permissions.granted)) {
    return {
      tone: "critical",
      icon: ResetIcon,
      disabled: true,
      label: "Discard changes",
      title: (0, import_jsx_runtime.jsx)(InsufficientPermissionsMessage, {
        operationLabel: "discard changes in this document",
        currentUser
      })
    };
  }
  return {
    tone: "critical",
    icon: ResetIcon,
    disabled: Boolean(discardChanges.disabled) || isPermissionsLoading,
    title: discardChanges.disabled && DISABLED_REASON_TITLE$3[discardChanges.disabled] || "",
    label: "Discard changes",
    onHandle: handle,
    dialog
  };
};
DiscardChangesAction.action = "discardChanges";
var DISABLED_REASON_TITLE$2 = {
  NOTHING_TO_DUPLICATE: "This document doesn’t yet exist so there‘s nothing to duplicate"
};
var DuplicateAction = (_ref24) => {
  let {
    id,
    type,
    onComplete
  } = _ref24;
  const {
    duplicate
  } = useDocumentOperation(id, type);
  const {
    navigateIntent
  } = useRouter();
  const [isDuplicating, setDuplicating] = (0, import_react.useState)(false);
  const [permissions, isPermissionsLoading] = useDocumentPairPermissions({
    id,
    type,
    permission: "duplicate"
  });
  const currentUser = useCurrentUser();
  const handle = (0, import_react.useCallback)(() => {
    const dupeId = v4_default();
    setDuplicating(true);
    duplicate.execute(dupeId);
    navigateIntent("edit", {
      id: dupeId,
      type
    });
    onComplete();
  }, [duplicate, navigateIntent, onComplete, type]);
  if (!isPermissionsLoading && !(permissions == null ? void 0 : permissions.granted)) {
    return {
      icon: CopyIcon,
      disabled: true,
      label: "Duplicate",
      title: (0, import_jsx_runtime.jsx)(InsufficientPermissionsMessage, {
        operationLabel: "duplicate this document",
        currentUser
      })
    };
  }
  return {
    icon: CopyIcon,
    disabled: isDuplicating || Boolean(duplicate.disabled) || isPermissionsLoading,
    label: isDuplicating ? "Duplicating…" : "Duplicate",
    title: duplicate.disabled && DISABLED_REASON_TITLE$2[duplicate.disabled] || "",
    onHandle: handle
  };
};
DuplicateAction.action = "duplicate";
var HistoryRestoreAction = (_ref25) => {
  let {
    id,
    type,
    revision,
    onComplete
  } = _ref25;
  const {
    restore
  } = useDocumentOperation(id, type);
  const {
    navigateIntent
  } = useRouter();
  const [isConfirmDialogOpen, setConfirmDialogOpen] = (0, import_react.useState)(false);
  const handleConfirm = (0, import_react.useCallback)(() => {
    restore.execute(revision);
    onComplete();
    setTimeout(() => navigateIntent("edit", {
      id,
      type
    }), 0);
  }, [restore, revision, navigateIntent, id, type, onComplete]);
  const handle = (0, import_react.useCallback)(() => {
    setConfirmDialogOpen(true);
  }, []);
  const dialog = (0, import_react.useMemo)(() => {
    if (isConfirmDialogOpen) {
      return {
        type: "confirm",
        tone: "critical",
        onCancel: onComplete,
        onConfirm: handleConfirm,
        message: (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, {
          children: "Are you sure you want to restore this document?"
        })
      };
    }
    return null;
  }, [handleConfirm, isConfirmDialogOpen, onComplete]);
  const isRevisionInitialVersion = revision === "@initial";
  const isRevisionLatestVersion = revision === void 0;
  if (isRevisionLatestVersion) {
    return null;
  }
  return {
    label: "Restore",
    color: "primary",
    onHandle: handle,
    title: isRevisionInitialVersion ? "You can't restore to the initial version" : "Restore to this version",
    icon: RestoreIcon,
    dialog,
    disabled: isRevisionInitialVersion
  };
};
HistoryRestoreAction.action = "restore";
var DocumentPaneContext = (0, import_react.createContext)(null);
function useDocumentPane() {
  const documentPane = (0, import_react.useContext)(DocumentPaneContext);
  if (!documentPane) {
    throw new Error("DocumentPane: missing context value");
  }
  return documentPane;
}
var DISABLED_REASON_TITLE$1 = {
  LIVE_EDIT_ENABLED: "Cannot publish since liveEdit is enabled for this document type",
  ALREADY_PUBLISHED: "Already published",
  NO_CHANGES: "No unpublished changes",
  NOT_READY: "Operation not ready"
};
function getDisabledReason(reason, publishedAt) {
  if (reason === "ALREADY_PUBLISHED" && publishedAt) {
    return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, {
      children: (0, import_jsx_runtime.jsxs)("span", {
        children: ["Published ", (0, import_jsx_runtime.jsx)(TimeAgo, {
          time: publishedAt
        })]
      })
    });
  }
  return DISABLED_REASON_TITLE$1[reason];
}
var PublishAction = (props) => {
  var _a2;
  const {
    id,
    type,
    liveEdit,
    draft,
    published
  } = props;
  const [publishState, setPublishState] = (0, import_react.useState)(null);
  const {
    publish
  } = useDocumentOperation(id, type);
  const validationStatus = useValidationStatus(id, type);
  const syncState = useSyncState(id, type);
  const {
    changesOpen,
    onHistoryOpen,
    documentId,
    documentType
  } = useDocumentPane();
  const editState = useEditState(documentId, documentType);
  const revision = ((editState == null ? void 0 : editState.draft) || (editState == null ? void 0 : editState.published) || {})._rev;
  const hasValidationErrors = validationStatus.validation.some(isValidationErrorMarker);
  const [publishScheduled, setPublishScheduled] = (0, import_react.useState)(false);
  const isSyncing = syncState.isSyncing;
  const isValidating = validationStatus.isValidating;
  const [permissions, isPermissionsLoading] = useDocumentPairPermissions({
    id,
    type,
    permission: "publish"
  });
  const currentUser = useCurrentUser();
  const title = publish.disabled ? getDisabledReason(publish.disabled, (published || {})._updatedAt) || "" : hasValidationErrors ? "There are validation errors that need to be fixed before this document can be published" : "";
  const hasDraft = Boolean(draft);
  const doPublish = (0, import_react.useCallback)(() => {
    publish.execute();
    setPublishState("publishing");
  }, [publish]);
  (0, import_react.useEffect)(() => {
    const validationComplete = validationStatus.isValidating === false && validationStatus.revision !== revision;
    if (!publishScheduled || isSyncing || !validationComplete) {
      return;
    }
    if (!hasValidationErrors) {
      doPublish();
    }
    setPublishScheduled(false);
  }, [isSyncing, doPublish, hasValidationErrors, publishScheduled, validationStatus.revision, revision, isValidating, validationStatus.isValidating]);
  (0, import_react.useEffect)(() => {
    const didPublish = publishState === "publishing" && !hasDraft;
    if (didPublish) {
      if (changesOpen) {
        onHistoryOpen();
      }
    }
    const nextState = didPublish ? "published" : null;
    const delay = didPublish ? 200 : 4e3;
    const timer2 = setTimeout(() => {
      setPublishState(nextState);
    }, delay);
    return () => clearTimeout(timer2);
  }, [changesOpen, publishState, hasDraft, onHistoryOpen]);
  const handle = (0, import_react.useCallback)(() => {
    if (syncState.isSyncing || validationStatus.isValidating || validationStatus.revision !== revision) {
      setPublishScheduled(true);
    } else {
      doPublish();
    }
  }, [syncState.isSyncing, validationStatus.isValidating, validationStatus.revision, revision, doPublish]);
  if (liveEdit) {
    return {
      tone: "positive",
      label: "Publish",
      title: "Live Edit is enabled for this content type and publishing happens automatically as you make changes",
      disabled: true
    };
  }
  if (!isPermissionsLoading && !(permissions == null ? void 0 : permissions.granted)) {
    return {
      tone: "positive",
      label: "Publish",
      title: (0, import_jsx_runtime.jsx)(InsufficientPermissionsMessage, {
        operationLabel: "publish this document",
        currentUser
      }),
      disabled: true
    };
  }
  const disabled = Boolean(publishScheduled || ((_a2 = editState == null ? void 0 : editState.transactionSyncLock) == null ? void 0 : _a2.enabled) || publishState === "publishing" || publishState === "published" || hasValidationErrors || publish.disabled);
  return {
    disabled: disabled || isPermissionsLoading,
    tone: "positive",
    label: (
      // eslint-disable-next-line no-nested-ternary
      publishState === "published" ? "Published" : publishScheduled || publishState === "publishing" ? "Publishing…" : "Publish"
    ),
    // @todo: Implement loading state, to show a `<Button loading />` state
    // loading: publishScheduled || publishState === 'publishing',
    icon: publishState === "published" ? CheckmarkIcon : PublishIcon,
    // eslint-disable-next-line no-nested-ternary
    title: publishScheduled ? "Waiting for tasks to finish before publishing" : publishState === "published" || publishState === "publishing" ? null : title,
    shortcut: disabled || publishScheduled ? null : "Ctrl+Alt+P",
    onHandle: handle
  };
};
PublishAction.action = "publish";
var DISABLED_REASON_TITLE = {
  NOT_PUBLISHED: "This document is not published"
};
var UnpublishAction = (_ref26) => {
  let {
    id,
    type,
    draft,
    onComplete,
    liveEdit
  } = _ref26;
  const {
    unpublish
  } = useDocumentOperation(id, type);
  const [isConfirmDialogOpen, setConfirmDialogOpen] = (0, import_react.useState)(false);
  const [permissions, isPermissionsLoading] = useDocumentPairPermissions({
    id,
    type,
    permission: "unpublish"
  });
  const currentUser = useCurrentUser();
  const handleCancel = (0, import_react.useCallback)(() => {
    setConfirmDialogOpen(false);
    onComplete();
  }, [onComplete]);
  const handleConfirm = (0, import_react.useCallback)(() => {
    setConfirmDialogOpen(false);
    unpublish.execute();
    onComplete();
  }, [onComplete, unpublish]);
  const dialog = (0, import_react.useMemo)(() => {
    if (isConfirmDialogOpen) {
      return {
        type: "dialog",
        onClose: onComplete,
        content: (0, import_jsx_runtime.jsx)(ConfirmDeleteDialogContainer, {
          id: (draft == null ? void 0 : draft._id) || id,
          type,
          action: "unpublish",
          onCancel: handleCancel,
          onConfirm: handleConfirm
        })
      };
    }
    return null;
  }, [draft, id, handleCancel, handleConfirm, isConfirmDialogOpen, onComplete, type]);
  if (liveEdit) {
    return null;
  }
  if (!isPermissionsLoading && !(permissions == null ? void 0 : permissions.granted)) {
    return {
      tone: "critical",
      icon: UnpublishIcon,
      label: "Unpublish",
      title: (0, import_jsx_runtime.jsx)(InsufficientPermissionsMessage, {
        operationLabel: "unpublish this document",
        currentUser
      }),
      disabled: true
    };
  }
  return {
    tone: "critical",
    icon: UnpublishIcon,
    disabled: Boolean(unpublish.disabled) || isPermissionsLoading,
    label: "Unpublish",
    title: unpublish.disabled ? DISABLED_REASON_TITLE[unpublish.disabled] : "",
    onHandle: () => setConfirmDialogOpen(true),
    dialog
  };
};
UnpublishAction.action = "unpublish";
var LiveEditBadge = (props) => {
  const {
    liveEdit
  } = props;
  if (liveEdit) {
    return {
      label: "Live",
      color: "danger"
    };
  }
  return null;
};
var _DEBUG = false;
var EMPTY_PARAMS$2 = {};
var LOADING_PANE = Symbol("LOADING_PANE");
var DOCUMENT_PANEL_PORTAL_ELEMENT = "documentPanelPortalElement";
var state = {
  activePanes: []
};
function setActivePanes(panes) {
  state.activePanes = panes;
}
function getIntentState(intent, params, routerState, payload) {
  var _a2;
  const panes = (routerState == null ? void 0 : routerState.panes) || [];
  const activePanes = state.activePanes || [];
  const editDocumentId = params.id || v4_default();
  const isTemplate = intent === "create" && params.template;
  for (let i = activePanes.length - 1; i >= 0; i--) {
    const pane = activePanes[i];
    if (typeof pane !== "object")
      continue;
    if (((_a2 = pane.canHandleIntent) == null ? void 0 : _a2.call(pane, intent, params, {
      pane,
      index: i
    })) || // see `resolveIntent.ts` for more info
    pane.type === "documentList" && pane.schemaTypeName === params.type && pane.options.filter === "_type == $type") {
      const paneParams = isTemplate ? {
        template: params.template
      } : EMPTY_PARAMS$2;
      return {
        panes: panes.slice(0, i).concat([[{
          id: editDocumentId,
          params: paneParams,
          payload
        }]])
      };
    }
  }
  return {
    intent,
    params,
    payload
  };
}
var EMPTY_PARAMS$1 = {};
function legacyEditParamsToState(params) {
  try {
    return JSON.parse(decodeURIComponent(params));
  } catch (err) {
    console.warn("Failed to parse JSON parameters");
    return {};
  }
}
function encodePanesSegment(panes) {
  return (panes || []).map((group) => group.map(encodeChunks).join("|")).map(encodeURIComponent).join(";");
}
function legacyEditParamsToPath(params) {
  return JSON.stringify(params);
}
function toState(pathSegment) {
  return parsePanesSegment(decodeURIComponent(pathSegment));
}
function toPath(panes) {
  return encodePanesSegment(panes);
}
var router = route.create("/", [
  // "Asynchronous intent resolving" route
  route.intents("/intent"),
  // Legacy fallback route, will be redirected to new format
  route.create("/edit/:type/:editDocumentId", [route.create({
    path: "/:params",
    transform: {
      params: {
        toState: legacyEditParamsToState,
        toPath: legacyEditParamsToPath
      }
    }
  })]),
  // The regular path - when the intent can be resolved to a specific pane
  route.create({
    path: "/:panes",
    // Legacy URLs, used to handle redirects
    children: [route.create("/:action", route.create("/:legacyEditDocumentId"))],
    transform: {
      panes: {
        toState,
        toPath
      }
    }
  })
]);
var panePattern = /^([.a-z0-9_-]+),?({.*?})?(?:(;|$))/i;
var isParam = (str) => /^[a-z0-9]+=[^=]+/i.test(str);
var isPayload = (str) => /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(str);
var exclusiveParams = ["view", "since", "rev", "inspect"];
var isTruthy = Boolean;
function parseChunks(chunks, initial) {
  return chunks.reduce((pane, chunk) => {
    if (isParam(chunk)) {
      const key = chunk.slice(0, chunk.indexOf("="));
      const value = chunk.slice(key.length + 1);
      pane.params = {
        ...pane.params,
        [decodeURIComponent(key)]: decodeURIComponent(value)
      };
    } else if (isPayload(chunk)) {
      pane.payload = tryParseBase64Payload(chunk);
    } else {
      console.warn("Unknown pane segment: %s - skipping", chunk);
    }
    return pane;
  }, {
    ...initial,
    params: EMPTY_PARAMS$1,
    payload: void 0
  });
}
function encodeChunks(pane, index, group) {
  const {
    payload,
    params = {},
    id
  } = pane;
  const [firstSibling] = group;
  const paneIsFirstSibling = pane === firstSibling;
  const sameAsFirst = index !== 0 && id === firstSibling.id;
  const encodedPayload = typeof payload === "undefined" ? void 0 : btoa(JSON.stringify(payload));
  const encodedParams = Object.entries(params).filter((entry) => {
    var _a2;
    const [key, value] = entry;
    if (!value)
      return false;
    if (paneIsFirstSibling)
      return true;
    const valueFromFirstSibling = (_a2 = firstSibling.params) == null ? void 0 : _a2[key];
    if (value === valueFromFirstSibling && !exclusiveParams.includes(key))
      return false;
    return true;
  }).map((_ref27) => {
    let [key, value] = _ref27;
    return "".concat(encodeURIComponent(key), "=").concat(encodeURIComponent(value));
  });
  return [sameAsFirst ? "" : id].concat([encodedParams.length > 0 && encodedParams, encodedPayload].filter(isTruthy).flat()).join(",") || ",";
}
function parsePanesSegment(str) {
  if (str.indexOf(",{") !== -1) {
    return parseOldPanesSegment(str);
  }
  return str.split(";").map((group) => {
    const [firstSibling, ...restOfSiblings] = group.split("|").map((segment) => {
      const [id, ...chunks] = segment.split(",");
      return parseChunks(chunks, {
        id
      });
    });
    return [firstSibling, ...restOfSiblings.map((sibling) => ({
      ...firstSibling,
      ...sibling,
      id: sibling.id || firstSibling.id,
      params: {
        ...(0, import_omit.default)(firstSibling.params, exclusiveParams),
        ...sibling.params
      },
      payload: sibling.payload || firstSibling.payload
    }))];
  }).filter((group) => group.length > 0);
}
function parseOldPanesSegment(str) {
  const chunks = [];
  let buffer = str;
  while (buffer.length) {
    const [match, id, payloadChunk] = buffer.match(panePattern) || [];
    if (!match) {
      buffer = buffer.slice(1);
      continue;
    }
    const payload = payloadChunk && tryParsePayload(payloadChunk);
    chunks.push({
      id,
      payload
    });
    buffer = buffer.slice(match.length);
  }
  return [chunks];
}
function tryParsePayload(json) {
  try {
    return JSON.parse(json);
  } catch (err) {
    console.warn("Failed to parse parameters: ".concat(err.message));
    return void 0;
  }
}
function tryParseBase64Payload(data) {
  return data ? tryParsePayload(atob(data)) : void 0;
}
var DOCUMENT_PANEL_MIN_WIDTH = 320;
var DOCUMENT_PANEL_INITIAL_MIN_WIDTH = 600;
var DOCUMENT_INSPECTOR_MIN_WIDTH = 320;
var DOCUMENT_INSPECTOR_MAX_WIDTH = 540;
var EMPTY_PARAMS = {};
var INSPECT_ACTION_PREFIX = "inspect:";
var DEFAULT_MENU_ITEM_GROUPS = [{
  id: "inspectors"
}, {
  id: "links"
}];
var HISTORY_INSPECTOR_NAME = "sanity/desk/history";
var VALIDATION_INSPECTOR_NAME = "sanity/desk/validation";
var Root$5 = styled_components_browser_esm_default(Card)({
  position: "relative",
  zIndex: 1,
  lineHeight: 0,
  "&:after": {
    content: '""',
    display: "block",
    position: "absolute",
    left: 0,
    bottom: -1,
    right: 0,
    borderBottom: "1px solid var(--card-border-color)",
    opacity: 0.5
  }
});
function DocumentInspectorHeader(props) {
  const {
    as: forwardedAs,
    children,
    closeButtonLabel,
    onClose,
    title,
    ...restProps
  } = props;
  return (0, import_jsx_runtime.jsxs)(Root$5, {
    ...restProps,
    as: forwardedAs,
    children: [(0, import_jsx_runtime.jsxs)(Flex, {
      padding: 2,
      children: [(0, import_jsx_runtime.jsx)(Box, {
        flex: 1,
        padding: 3,
        children: (0, import_jsx_runtime.jsx)(Text, {
          as: "h1",
          size: 1,
          weight: "semibold",
          children: title
        })
      }), (0, import_jsx_runtime.jsx)(Box, {
        flex: "none",
        padding: 1,
        children: (0, import_jsx_runtime.jsx)(Button, {
          "aria-label": closeButtonLabel,
          fontSize: 1,
          icon: CloseIcon,
          mode: "bleed",
          onClick: onClose,
          padding: 2
        })
      })]
    }), children]
  });
}
var DeskToolContext = (0, import_react.createContext)(null);
function useDeskTool() {
  const deskTool2 = (0, import_react.useContext)(DeskToolContext);
  if (!deskTool2)
    throw new Error("DeskTool: missing context value");
  return deskTool2;
}
var __freeze$5 = Object.freeze;
var __defProp$k = Object.defineProperty;
var __template$5 = (cooked, raw) => __freeze$5(__defProp$k(cooked, "raw", {
  value: __freeze$5(raw || cooked.slice())
}));
var _a$5;
var Root$4 = styled_components_browser_esm_default.div(_a$5 || (_a$5 = __template$5(["\n  position: absolute;\n  top: 0;\n  left: -4px;\n  bottom: 0;\n  width: 9px;\n  z-index: 201;\n  cursor: ew-resize;\n\n  /* Border */\n  & > span:nth-child(1) {\n    display: block;\n    border-left: 1px solid var(--card-border-color);\n    position: absolute;\n    top: 0;\n    left: 4px;\n    bottom: 0;\n    transition: opacity 200ms;\n    opacity: 0.5;\n  }\n\n  /* Hover effect */\n  & > span:nth-child(2) {\n    display: block;\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 9px;\n    bottom: 0;\n    background-color: var(--card-border-color);\n    opacity: 0;\n    transition: opacity 150ms;\n  }\n\n  @media (hover: hover) {\n    &:hover > span:nth-child(2) {\n      opacity: 0.2;\n    }\n  }\n"])));
function Resizer(props) {
  const {
    onResize,
    onResizeStart
  } = props;
  const mouseXRef = (0, import_react.useRef)(0);
  const handleMouseDown = (0, import_react.useCallback)((event) => {
    event.preventDefault();
    mouseXRef.current = event.pageX;
    onResizeStart();
    const handleMouseMove = (e) => {
      e.preventDefault();
      onResize(e.pageX - mouseXRef.current);
    };
    const handleMouseUp = () => {
      window.removeEventListener("mousemove", handleMouseMove);
      window.removeEventListener("mouseup", handleMouseUp);
    };
    window.addEventListener("mousemove", handleMouseMove);
    window.addEventListener("mouseup", handleMouseUp);
  }, [onResize, onResizeStart]);
  return (0, import_jsx_runtime.jsxs)(Root$4, {
    onMouseDown: handleMouseDown,
    children: [(0, import_jsx_runtime.jsx)("span", {}), (0, import_jsx_runtime.jsx)("span", {})]
  });
}
var __freeze$4 = Object.freeze;
var __defProp$j = Object.defineProperty;
var __template$4 = (cooked, raw) => __freeze$4(__defProp$j(cooked, "raw", {
  value: __freeze$4(raw || cooked.slice())
}));
var _a$4;
var Root$3 = styled_components_browser_esm_default(Box)(_a$4 || (_a$4 = __template$4(["\n  position: relative;\n  flex: 1;\n  padding-left: 1px;\n"])));
function Resizable(props) {
  const {
    as: forwardedAs,
    children,
    minWidth,
    maxWidth,
    ...restProps
  } = props;
  const [element, setElement] = (0, import_react.useState)(null);
  const elementWidthRef = (0, import_react.useRef)();
  const [targetWidth, setTargetWidth] = (0, import_react.useState)();
  const handleResizeStart = (0, import_react.useCallback)(() => {
    elementWidthRef.current = element == null ? void 0 : element.offsetWidth;
  }, [element]);
  const handleResize = (0, import_react.useCallback)((deltaX) => {
    const w = elementWidthRef.current;
    if (!w)
      return;
    setTargetWidth(Math.min(Math.max(w - deltaX, minWidth), maxWidth));
  }, [minWidth, maxWidth]);
  const style = (0, import_react.useMemo)(() => targetWidth ? {
    flex: "none",
    width: targetWidth
  } : {
    minWidth,
    maxWidth
  }, [minWidth, maxWidth, targetWidth]);
  return (0, import_jsx_runtime.jsxs)(Root$3, {
    as: forwardedAs,
    ...restProps,
    ref: setElement,
    style,
    children: [children, (0, import_jsx_runtime.jsx)(Resizer, {
      onResize: handleResize,
      onResizeStart: handleResizeStart
    })]
  });
}
function getPathTypes(options) {
  const {
    path,
    schemaType,
    value
  } = options;
  const result = [];
  let s = schemaType;
  let v = value;
  for (const segment of path) {
    if (typeof segment === "string") {
      if (!isRecord$2(v) && v !== void 0) {
        throw new Error("Parent value is not an object, cannot get path segment: .".concat(segment));
      }
      if (s.jsonType !== "object") {
        throw new Error("Parent type is not an object schema type, cannot get path segment: .".concat(segment));
      }
      v = v == null ? void 0 : v[segment];
      const field = s.fields.find((f) => f.name === segment);
      if (!field) {
        throw new Error("Field type not found: .".concat(segment));
      }
      s = field.type;
      result.push(s);
      continue;
    }
    if (typeof segment === "number") {
      if (!isArray(v) && v !== void 0) {
        throw new Error("Parent value is not an array, cannot get path segment: [".concat(segment, "]"));
      }
      if (s.jsonType !== "array") {
        throw new Error("Parent type is not an array schema type, cannot get path segment: [".concat(segment, "]"));
      }
      v = v == null ? void 0 : v[segment];
      const itemType = s.of.find((ofType) => {
        if (typeof v === "string") {
          return ofType.jsonType === "string";
        }
        if (typeof v === "number") {
          return ofType.jsonType === "number";
        }
        if (typeof v === "boolean") {
          return ofType.jsonType === "boolean";
        }
        if (isRecord$2(v)) {
          return ofType.name === (v == null ? void 0 : v._type);
        }
        return false;
      });
      if (!itemType) {
        throw new Error("Item type not found: [".concat(segment, "]"));
      }
      s = itemType;
      result.push(s);
      continue;
    }
    if (isRecord$2(segment) && segment._key) {
      if (!isArray(v)) {
        throw new Error("Parent value is not an anrray, cannot get path segment: [_key == ".concat(segment, "]"));
      }
      if (s.jsonType !== "array") {
        throw new Error("Parent type is not an array schema type, cannot get path segment: .".concat(segment));
      }
      const values = v != null ? v : [];
      v = values.find((i) => isRecord$2(i) && i._key === segment._key);
      if (!isRecord$2(v)) {
        throw new Error("Array item not found: [_key == ".concat(segment._key, "]"));
      }
      const ofType = s.of.find((i) => isRecord$2(v) && i.name === (v == null ? void 0 : v._type));
      if (!ofType) {
        throw new Error("Array item type not found: .".concat(v == null ? void 0 : v._type));
      }
      s = ofType;
      result.push(s);
      continue;
    }
    throw new Error("Invalid path segment: ".concat(JSON.stringify(segment)));
  }
  return result;
}
var MARKER_ICON = {
  error: ErrorOutlineIcon,
  warning: WarningOutlineIcon,
  info: InfoOutlineIcon
};
var MARKER_TONE = {
  error: "critical",
  warning: "caution",
  info: "primary"
};
function ValidationInspector(props) {
  const {
    onClose
  } = props;
  const {
    onFocus,
    onPathOpen,
    schemaType,
    validation,
    value
  } = useDocumentPane();
  const handleOpen = (0, import_react.useCallback)((path) => {
    onPathOpen(path);
    onFocus(path);
  }, [onFocus, onPathOpen]);
  return (0, import_jsx_runtime.jsxs)(Flex, {
    direction: "column",
    height: "fill",
    overflow: "hidden",
    children: [(0, import_jsx_runtime.jsx)(DocumentInspectorHeader, {
      as: "header",
      closeButtonLabel: "Close validation",
      flex: "none",
      onClose,
      title: "Validation"
    }), (0, import_jsx_runtime.jsxs)(Card, {
      flex: 1,
      overflow: "auto",
      padding: 3,
      children: [validation.length === 0 && (0, import_jsx_runtime.jsx)(Box, {
        padding: 2,
        children: (0, import_jsx_runtime.jsx)(Text, {
          muted: true,
          size: 1,
          children: "No validation errors"
        })
      }), validation.length > 0 && (0, import_jsx_runtime.jsx)(Stack, {
        space: 2,
        children: validation.map((marker) => (0, import_jsx_runtime.jsx)(ValidationCard, {
          marker,
          onOpen: handleOpen,
          schemaType,
          value
        }, pathToString(marker.path)))
      })]
    })]
  });
}
function ValidationCard(props) {
  const {
    marker,
    onOpen,
    schemaType,
    value
  } = props;
  const handleOpen = (0, import_react.useCallback)(() => onOpen(marker.path), [marker, onOpen]);
  const [errorInfo, setErrorInfo] = (0, import_react.useState)(null);
  return (0, import_jsx_runtime.jsxs)(ErrorBoundary, {
    onCatch: setErrorInfo,
    children: [errorInfo && (0, import_jsx_runtime.jsx)(Card, {
      padding: 3,
      radius: 2,
      tone: "critical",
      children: (0, import_jsx_runtime.jsxs)(Text, {
        size: 1,
        children: ["ERROR: ", errorInfo.error.message]
      })
    }), !errorInfo && (0, import_jsx_runtime.jsx)(Card, {
      __unstable_focusRing: true,
      as: "button",
      onClick: handleOpen,
      padding: 3,
      radius: 2,
      tone: MARKER_TONE[marker.level],
      children: (0, import_jsx_runtime.jsxs)(Flex, {
        align: "flex-start",
        gap: 3,
        children: [(0, import_jsx_runtime.jsx)(Box, {
          flex: "none",
          children: (0, import_jsx_runtime.jsx)(Text, {
            size: 1,
            children: (0, import_react.createElement)(MARKER_ICON[marker.level])
          })
        }), (0, import_jsx_runtime.jsxs)(Stack, {
          flex: 1,
          space: 2,
          children: [(0, import_jsx_runtime.jsx)(DocumentNodePathBreadcrumbs, {
            path: marker.path,
            schemaType,
            value
          }), (0, import_jsx_runtime.jsx)(Text, {
            muted: true,
            size: 1,
            children: marker.item.message
          })]
        })]
      })
    })]
  });
}
function DocumentNodePathBreadcrumbs(props) {
  const {
    path,
    schemaType,
    value
  } = props;
  const pathTypes = (0, import_react.useMemo)(() => getPathTypes({
    path,
    schemaType,
    value
  }), [path, schemaType, value]);
  return (0, import_jsx_runtime.jsx)(Text, {
    size: 1,
    children: pathTypes.map((t, i) => (0, import_jsx_runtime.jsxs)(import_react.Fragment, {
      children: [i > 0 && (0, import_jsx_runtime.jsx)("span", {
        style: {
          color: "var(--card-muted-fg-color)",
          opacity: 0.5
        },
        children: " / "
      }), (0, import_jsx_runtime.jsx)("span", {
        style: {
          fontWeight: 500
        },
        children: t.title || t.name
      })]
    }, i))
  });
}
function useMenuItem(props) {
  const {
    documentId,
    documentType
  } = props;
  const {
    validation: validationMarkers
  } = useValidationStatus(documentId, documentType);
  const validation = (0, import_react.useMemo)(() => validationMarkers.map((item) => ({
    level: item.level,
    message: item.item.message,
    path: item.path
  })), [validationMarkers]);
  const hasErrors = validation.some(isValidationError);
  const hasWarnings = validation.some(isValidationWarning);
  const icon = (0, import_react.useMemo)(() => {
    if (hasErrors)
      return ErrorOutlineIcon;
    if (hasWarnings)
      return WarningOutlineIcon;
    return CheckmarkCircleIcon;
  }, [hasErrors, hasWarnings]);
  const tone = (0, import_react.useMemo)(() => {
    if (hasErrors)
      return "critical";
    if (hasWarnings)
      return "caution";
    return "positive";
  }, [hasErrors, hasWarnings]);
  return {
    hidden: validation.length === 0,
    icon,
    title: "Validation",
    tone,
    showAsAction: true
  };
}
var validationInspector = {
  name: VALIDATION_INSPECTOR_NAME,
  component: ValidationInspector,
  useMenuItem
};
var TIMELINE_LABELS = {
  create: "created",
  delete: "deleted",
  discardDraft: "discarded draft",
  initial: "created",
  editDraft: "edited",
  editLive: "live edited",
  publish: "published",
  unpublish: "unpublished"
};
var TIMELINE_ICON_COMPONENTS = {
  create: AddCircleIcon,
  delete: TrashIcon,
  discardDraft: CloseIcon,
  initial: AddCircleIcon,
  editDraft: EditIcon,
  editLive: EditIcon,
  publish: PublishIcon,
  unpublish: UnpublishIcon
};
function formatTimelineEventLabel(type) {
  return TIMELINE_LABELS[type];
}
function getTimelineEventIconComponent(type) {
  return TIMELINE_ICON_COMPONENTS[type];
}
function UserAvatarStack(_ref28) {
  let {
    maxLength,
    userIds
  } = _ref28;
  return (0, import_jsx_runtime.jsx)(AvatarStack, {
    maxLength,
    children: userIds.map((userId) => (0, import_jsx_runtime.jsx)(UserAvatar, {
      user: userId,
      withTooltip: true
    }, userId))
  });
}
var __freeze$3 = Object.freeze;
var __defProp$i = Object.defineProperty;
var __template$3 = (cooked, raw) => __freeze$3(__defProp$i(cooked, "raw", {
  value: __freeze$3(raw || cooked.slice())
}));
var _a$3;
var _b$1;
var _c$1;
var _d$1;
var _e;
var _f;
var IconWrapper = styled_components_browser_esm_default(Flex)((_ref29) => {
  let {
    theme
  } = _ref29;
  var _a2;
  const borderColor = (_a2 = theme.sanity.color.base.skeleton) == null ? void 0 : _a2.from;
  return Ae(_a$3 || (_a$3 = __template$3(["\n    --timeline-hairline-width: 1px;\n    position: relative;\n    z-index: 2;\n    margin: 0;\n    padding: 0;\n\n    &::before {\n      position: absolute;\n      content: '';\n      height: 100%;\n      width: var(--timeline-hairline-width);\n      background: ", ";\n      top: 0;\n      left: calc((100% - var(--timeline-hairline-width)) / 2);\n      z-index: 1;\n    }\n  "])), borderColor);
});
var Root$2 = styled_components_browser_esm_default(Button)((_ref30) => {
  let {
    $selected
  } = _ref30;
  return Ae(_c$1 || (_c$1 = __template$3(["\n    position: relative;\n    width: 100%;\n\n    /* Line styling */\n    &[data-first] ", "::before {\n      height: 50%;\n      top: unset;\n      bottom: 0;\n    }\n\n    &[data-last] ", "::before {\n      height: 50%;\n    }\n\n    ", "\n  "])), IconWrapper, IconWrapper, $selected && Ae(_b$1 || (_b$1 = __template$3(["\n      ", "::before {\n        background: transparent;\n      }\n    "])), IconWrapper));
});
var IconBox = styled_components_browser_esm_default(Box)(_d$1 || (_d$1 = __template$3(["\n  background: var(--card-bg-color);\n  border-radius: 50px;\n  position: relative;\n  z-index: 2;\n"])));
var EventLabel = styled_components_browser_esm_default(Text)(_e || (_e = __template$3(["\n  text-transform: capitalize;\n"])));
var TimestampBox = styled_components_browser_esm_default(Box)(_f || (_f = __template$3(["\n  min-width: 1rem;\n  margin-left: ", ";\n"])), (_ref31) => {
  let {
    theme
  } = _ref31;
  return "-".concat(rem(theme.sanity.space[1]));
});
var TIMELINE_ITEM_EVENT_TONE = {
  initial: "primary",
  create: "primary",
  publish: "positive",
  editLive: "caution",
  editDraft: "caution",
  unpublish: "critical",
  discardDraft: "critical",
  delete: "critical",
  withinSelection: "primary"
};
function TimelineItem(_ref32) {
  let {
    chunk,
    isFirst,
    isLast,
    isLatest,
    isSelected,
    onSelect,
    timestamp,
    type
  } = _ref32;
  const iconComponent = getTimelineEventIconComponent(type);
  const authorUserIds = Array.from(chunk.authors);
  const formattedTimestamp = (0, import_react.useMemo)(() => {
    const parsedDate = new Date(timestamp);
    const formattedDate = format(parsedDate, "MMM d, yyyy, hh:mm a");
    return formattedDate;
  }, [timestamp]);
  const handleClick = (0, import_react.useCallback)((evt) => {
    evt.preventDefault();
    evt.stopPropagation();
    onSelect(chunk);
  }, [onSelect, chunk]);
  return (0, import_jsx_runtime.jsx)(Root$2, {
    $selected: isSelected,
    "data-chunk-id": chunk.id,
    "data-first": isFirst ? true : void 0,
    "data-last": isLast ? true : void 0,
    "data-ui": "timelineItem",
    mode: isSelected ? "default" : "bleed",
    onClick: handleClick,
    padding: 0,
    radius: 2,
    tone: isSelected ? "primary" : TIMELINE_ITEM_EVENT_TONE[chunk.type],
    children: (0, import_jsx_runtime.jsx)(Box, {
      paddingX: 2,
      children: (0, import_jsx_runtime.jsxs)(Flex, {
        align: "stretch",
        children: [(0, import_jsx_runtime.jsx)(IconWrapper, {
          align: "center",
          children: (0, import_jsx_runtime.jsx)(IconBox, {
            padding: 2,
            children: (0, import_jsx_runtime.jsx)(Text, {
              size: 2,
              children: iconComponent && (0, import_react.createElement)(iconComponent)
            })
          })
        }), (0, import_jsx_runtime.jsxs)(Stack, {
          space: 2,
          margin: 2,
          children: [isLatest && (0, import_jsx_runtime.jsx)(Flex, {
            children: (0, import_jsx_runtime.jsx)(Card, {
              padding: 1,
              radius: 2,
              shadow: 1,
              tone: isSelected ? "primary" : TIMELINE_ITEM_EVENT_TONE[chunk.type],
              children: (0, import_jsx_runtime.jsx)(Label, {
                muted: true,
                size: 0,
                children: "Latest"
              })
            })
          }), (0, import_jsx_runtime.jsx)(Box, {
            children: (0, import_jsx_runtime.jsx)(EventLabel, {
              size: 1,
              weight: "medium",
              children: formatTimelineEventLabel(type) || (0, import_jsx_runtime.jsx)("code", {
                children: type
              })
            })
          }), (0, import_jsx_runtime.jsx)(TimestampBox, {
            paddingX: 1,
            children: (0, import_jsx_runtime.jsx)(Text, {
              size: 0,
              muted: true,
              children: formattedTimestamp
            })
          })]
        }), (0, import_jsx_runtime.jsx)(Flex, {
          flex: 1,
          justify: "flex-end",
          align: "center",
          children: (0, import_jsx_runtime.jsx)(UserAvatarStack, {
            maxLength: 3,
            userIds: authorUserIds
          })
        })]
      })
    })
  });
}
var __freeze$2 = Object.freeze;
var __defProp$h = Object.defineProperty;
var __template$2 = (cooked, raw) => __freeze$2(__defProp$h(cooked, "raw", {
  value: __freeze$2(raw || cooked.slice())
}));
var _a$2;
var _b;
var _c;
var _d;
var StackWrapper = styled_components_browser_esm_default(Stack)(_a$2 || (_a$2 = __template$2(["\n  max-width: 200px;\n"])));
var ListWrapper = styled_components_browser_esm_default(Flex)(_b || (_b = __template$2(["\n  max-height: calc(100vh - 198px);\n  min-width: 244px;\n"])));
var Root$1 = styled_components_browser_esm_default(Box)((_ref33) => {
  let {
    $visible
  } = _ref33;
  return Ae(_d || (_d = __template$2(["\n    opacity: 0;\n    pointer-events: none;\n\n    ", "\n  "])), $visible && Ae(_c || (_c = __template$2(["\n      opacity: 1;\n      pointer-events: auto;\n    "]))));
});
var Timeline = (_ref34) => {
  let {
    chunks,
    disabledBeforeFirstChunk,
    hasMoreChunks,
    lastChunk,
    onLoadMore,
    onSelect,
    firstChunk
  } = _ref34;
  const [mounted, setMounted] = (0, import_react.useState)(false);
  const filteredChunks = (0, import_react.useMemo)(() => {
    return chunks.filter((c) => {
      if (disabledBeforeFirstChunk && firstChunk) {
        return c.index < firstChunk.index;
      }
      return true;
    });
  }, [chunks, disabledBeforeFirstChunk, firstChunk]);
  const selectedIndex = (0, import_react.useMemo)(() => (lastChunk == null ? void 0 : lastChunk.id) ? filteredChunks.findIndex((c) => c.id === lastChunk.id) : -1, [lastChunk == null ? void 0 : lastChunk.id, filteredChunks]);
  const renderItem = (0, import_react.useCallback)((chunk, _ref35) => {
    let {
      activeIndex
    } = _ref35;
    const isFirst = activeIndex === 0;
    const isLast = filteredChunks && activeIndex === filteredChunks.length - 1 || false;
    return (0, import_jsx_runtime.jsxs)(Box, {
      paddingBottom: isLast ? 1 : 0,
      paddingTop: isFirst ? 1 : 0,
      paddingX: 1,
      children: [(0, import_jsx_runtime.jsx)(TimelineItem, {
        chunk,
        isFirst,
        isLast,
        isLatest: activeIndex === 0 && !disabledBeforeFirstChunk,
        isSelected: activeIndex === selectedIndex,
        onSelect,
        timestamp: chunk.endTimestamp,
        type: chunk.type
      }), activeIndex === filteredChunks.length - 1 && hasMoreChunks && (0, import_jsx_runtime.jsx)(Flex, {
        align: "center",
        justify: "center",
        padding: 4,
        children: (0, import_jsx_runtime.jsx)(Spinner, {
          muted: true
        })
      })]
    });
  }, [disabledBeforeFirstChunk, filteredChunks, hasMoreChunks, onSelect, selectedIndex]);
  (0, import_react.useEffect)(() => setMounted(true), []);
  return (0, import_jsx_runtime.jsxs)(Root$1, {
    $visible: !selectedIndex || mounted,
    "data-ui": "timeline",
    children: [filteredChunks.length === 0 && (0, import_jsx_runtime.jsxs)(StackWrapper, {
      padding: 3,
      space: 3,
      children: [(0, import_jsx_runtime.jsx)(Text, {
        size: 1,
        weight: "semibold",
        children: "No document history"
      }), (0, import_jsx_runtime.jsx)(Text, {
        muted: true,
        size: 1,
        children: "When changing the content of the document, the document versions will appear in this menu."
      })]
    }), filteredChunks.length > 0 && (0, import_jsx_runtime.jsx)(ListWrapper, {
      direction: "column",
      children: (0, import_jsx_runtime.jsx)(CommandList, {
        activeItemDataAttr: "data-hovered",
        ariaLabel: "Document revisions",
        autoFocus: "list",
        initialIndex: selectedIndex,
        initialScrollAlign: "center",
        itemHeight: 40,
        items: filteredChunks,
        onEndReached: onLoadMore,
        onEndReachedIndexOffset: 20,
        overscan: 5,
        renderItem,
        wrapAround: false
      })
    })]
  });
};
Timeline.displayName = "Timeline";
function TimelineError() {
  return (0, import_jsx_runtime.jsxs)(Flex, {
    align: "flex-start",
    gap: 3,
    padding: 4,
    children: [(0, import_jsx_runtime.jsx)(TextWithTone, {
      tone: "critical",
      children: (0, import_jsx_runtime.jsx)(ErrorOutlineIcon, {})
    }), (0, import_jsx_runtime.jsxs)(Stack, {
      space: 4,
      children: [(0, import_jsx_runtime.jsx)(TextWithTone, {
        size: 1,
        tone: "critical",
        weight: "semibold",
        children: "An error occurred whilst retrieving document changes."
      }), (0, import_jsx_runtime.jsx)(TextWithTone, {
        size: 1,
        tone: "critical",
        children: "Document history transactions have not been affected."
      })]
    })]
  });
}
var __freeze$1 = Object.freeze;
var __defProp$g = Object.defineProperty;
var __template$1 = (cooked, raw) => __freeze$1(__defProp$g(cooked, "raw", {
  value: __freeze$1(raw || cooked.slice())
}));
var _a$1;
var Root = styled_components_browser_esm_default(Popover)(_a$1 || (_a$1 = __template$1(["\n  overflow: hidden;\n  overflow: clip;\n"])));
function TimelineMenu(_ref36) {
  let {
    chunk,
    mode,
    placement
  } = _ref36;
  const {
    setTimelineRange,
    setTimelineMode,
    timelineError,
    ready,
    timelineStore
  } = useDocumentPane();
  const [open, setOpen] = (0, import_react.useState)(false);
  const [button, setButton] = (0, import_react.useState)(null);
  const [popover, setPopover] = (0, import_react.useState)(null);
  const toast = useToast();
  const chunks = useTimelineSelector(timelineStore, (state2) => state2.chunks);
  const loading = useTimelineSelector(timelineStore, (state2) => state2.isLoading);
  const hasMoreChunks = useTimelineSelector(timelineStore, (state2) => state2.hasMoreChunks);
  const realRevChunk = useTimelineSelector(timelineStore, (state2) => state2.realRevChunk);
  const sinceTime = useTimelineSelector(timelineStore, (state2) => state2.sinceTime);
  const handleOpen = (0, import_react.useCallback)(() => {
    setTimelineMode(mode);
    setOpen(true);
  }, [mode, setTimelineMode]);
  const handleClose = (0, import_react.useCallback)(() => {
    setTimelineMode("closed");
    setOpen(false);
  }, [setTimelineMode]);
  const handleClickOutside = (0, import_react.useCallback)(() => {
    if (open) {
      handleClose();
    }
  }, [handleClose, open]);
  const handleGlobalKeyDown = (0, import_react.useCallback)((event) => {
    if (open && (event.key === "Escape" || event.key === "Tab")) {
      handleClose();
      button == null ? void 0 : button.focus();
    }
  }, [button, handleClose, open]);
  useClickOutside(handleClickOutside, [button, popover]);
  useGlobalKeyDown(handleGlobalKeyDown);
  const selectRev = (0, import_react.useCallback)((revChunk) => {
    try {
      const [sinceId, revId] = timelineStore.findRangeForRev(revChunk);
      setTimelineMode("closed");
      setTimelineRange(sinceId, revId);
    } catch (err) {
      toast.push({
        closable: true,
        description: err.message,
        status: "error",
        title: "Unable to load revision"
      });
    }
  }, [setTimelineMode, setTimelineRange, timelineStore, toast]);
  const selectSince = (0, import_react.useCallback)((sinceChunk) => {
    try {
      const [sinceId, revId] = timelineStore.findRangeForSince(sinceChunk);
      setTimelineMode("closed");
      setTimelineRange(sinceId, revId);
    } catch (err) {
      toast.push({
        closable: true,
        description: err.message,
        status: "error",
        title: "Unable to load revision"
      });
    }
  }, [setTimelineMode, setTimelineRange, timelineStore, toast]);
  const handleLoadMore = (0, import_react.useCallback)(() => {
    if (!loading) {
      timelineStore.loadMore();
    }
  }, [loading, timelineStore]);
  const content = timelineError ? (0, import_jsx_runtime.jsx)(TimelineError, {}) : (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
    children: [mode === "rev" && (0, import_jsx_runtime.jsx)(Timeline, {
      chunks,
      firstChunk: realRevChunk,
      hasMoreChunks,
      lastChunk: realRevChunk,
      onLoadMore: handleLoadMore,
      onSelect: selectRev
    }), mode === "since" && (0, import_jsx_runtime.jsx)(Timeline, {
      chunks,
      disabledBeforeFirstChunk: true,
      firstChunk: realRevChunk,
      hasMoreChunks,
      lastChunk: sinceTime,
      onLoadMore: handleLoadMore,
      onSelect: selectSince
    })]
  });
  const timeLabel = useFormattedTimestamp((chunk == null ? void 0 : chunk.endTimestamp) || "");
  const revLabel = chunk ? "".concat((0, import_upperFirst.default)(formatTimelineEventLabel(chunk.type)), ": ").concat(timeLabel) : "Latest version";
  const sinceLabel = chunk ? "Since: ".concat(timeLabel) : "Since: unknown version";
  const buttonLabel = mode === "rev" ? revLabel : sinceLabel;
  return (0, import_jsx_runtime.jsx)(Root, {
    constrainSize: true,
    content: open && content,
    "data-ui": "versionMenu",
    open,
    placement,
    portal: true,
    ref: setPopover,
    children: (0, import_jsx_runtime.jsx)(Button, {
      disabled: !ready,
      mode: "bleed",
      fontSize: 1,
      padding: 2,
      iconRight: SelectIcon,
      onClick: open ? handleClose : handleOpen,
      ref: setButton,
      selected: open,
      style: {
        maxWidth: "100%"
      },
      text: ready ? buttonLabel : "Loading history"
    })
  });
}
function useFormattedTimestamp(time) {
  const formatted = (0, import_react.useMemo)(() => {
    const parsedDate = time ? new Date(time) : /* @__PURE__ */ new Date();
    const formattedDate = format(parsedDate, "MMM d, yyyy, hh:mm a");
    return formattedDate;
  }, [time]);
  return formatted;
}
function LoadingContent() {
  return (0, import_jsx_runtime.jsx)(Delay, {
    ms: 300,
    children: (0, import_jsx_runtime.jsxs)(Flex, {
      align: "center",
      direction: "column",
      height: "fill",
      justify: "center",
      paddingTop: 3,
      children: [(0, import_jsx_runtime.jsx)(Spinner, {
        muted: true
      }), (0, import_jsx_runtime.jsx)(Box, {
        marginTop: 3,
        children: (0, import_jsx_runtime.jsx)(Text, {
          align: "center",
          muted: true,
          size: 1,
          children: "Loading changes"
        })
      })]
    })
  });
}
function collectLatestAuthorAnnotations(diff) {
  const authorMap = /* @__PURE__ */ new Map();
  visitDiff(diff, (child) => {
    if (child.action === "unchanged" || !("annotation" in child) || !child.annotation) {
      return true;
    }
    const {
      author,
      timestamp
    } = child.annotation;
    const previous = authorMap.get(author);
    if (!previous || previous.timestamp < timestamp) {
      authorMap.set(author, child.annotation);
    }
    return true;
  });
  return Array.from(authorMap.values()).sort((a, b) => a.timestamp < b.timestamp ? 1 : -1);
}
var __freeze = Object.freeze;
var __defProp$f = Object.defineProperty;
var __template = (cooked, raw) => __freeze(__defProp$f(cooked, "raw", {
  value: __freeze(raw || cooked.slice())
}));
var _a;
var Scroller = styled_components_browser_esm_default(ScrollContainer)(_a || (_a = __template(["\n  height: 100%;\n  overflow: auto;\n  position: relative;\n  scroll-behavior: smooth;\n"])));
function ChangesInspector(props) {
  const {
    onClose
  } = props;
  const {
    documentId,
    schemaType,
    timelineError,
    timelineStore,
    value
  } = useDocumentPane();
  const scrollRef = (0, import_react.useRef)(null);
  const diff = useTimelineSelector(timelineStore, (state2) => state2.diff);
  const onOlderRevision = useTimelineSelector(timelineStore, (state2) => state2.onOlderRevision);
  const selectionState = useTimelineSelector(timelineStore, (state2) => state2.selectionState);
  const sinceTime = useTimelineSelector(timelineStore, (state2) => state2.sinceTime);
  const loading = selectionState === "loading";
  const isComparingCurrent = !onOlderRevision;
  const documentContext = import_react.default.useMemo(() => ({
    documentId,
    schemaType,
    FieldWrapper: ChangeFieldWrapper,
    rootDiff: diff,
    isComparingCurrent,
    value
  }), [documentId, diff, isComparingCurrent, schemaType, value]);
  const changeAnnotations = import_react.default.useMemo(() => diff ? collectLatestAuthorAnnotations(diff) : [], [diff]);
  return (0, import_jsx_runtime.jsxs)(Flex, {
    "data-testid": "review-changes-pane",
    direction: "column",
    height: "fill",
    overflow: "hidden",
    children: [(0, import_jsx_runtime.jsx)(DocumentInspectorHeader, {
      as: "header",
      closeButtonLabel: "Close review changes",
      flex: "none",
      onClose,
      title: "Review changes",
      children: (0, import_jsx_runtime.jsxs)(Flex, {
        gap: 1,
        padding: 3,
        paddingTop: 0,
        paddingBottom: 2,
        children: [(0, import_jsx_runtime.jsx)(Box, {
          flex: 1,
          children: (0, import_jsx_runtime.jsx)(TimelineMenu, {
            mode: "since",
            chunk: sinceTime,
            placement: "bottom-start"
          })
        }), (0, import_jsx_runtime.jsx)(Box, {
          flex: "none",
          children: (0, import_jsx_runtime.jsx)(DiffTooltip, {
            annotations: changeAnnotations,
            description: "Changes by",
            portal: true,
            children: (0, import_jsx_runtime.jsx)(AvatarStack, {
              maxLength: 4,
              "aria-label": "Changes by",
              children: changeAnnotations.map((_ref37) => {
                let {
                  author
                } = _ref37;
                return (0, import_jsx_runtime.jsx)(UserAvatar, {
                  user: author
                }, author);
              })
            })
          })
        })]
      })
    }), (0, import_jsx_runtime.jsx)(Card, {
      flex: 1,
      children: (0, import_jsx_runtime.jsx)(BoundaryElementProvider, {
        element: scrollRef.current,
        children: (0, import_jsx_runtime.jsx)(Scroller, {
          "data-ui": "Scroller",
          ref: scrollRef,
          children: (0, import_jsx_runtime.jsx)(Box, {
            flex: 1,
            padding: 4,
            children: (0, import_jsx_runtime.jsx)(Content, {
              diff,
              documentContext,
              error: timelineError,
              loading,
              schemaType
            })
          })
        })
      })
    })]
  });
}
function Content(_ref38) {
  let {
    error,
    diff,
    documentContext,
    loading,
    schemaType
  } = _ref38;
  if (error) {
    return (0, import_jsx_runtime.jsx)(NoChanges, {});
  }
  if (loading) {
    return (0, import_jsx_runtime.jsx)(LoadingContent, {});
  }
  if (!diff) {
    return (0, import_jsx_runtime.jsx)(NoChanges, {});
  }
  return (0, import_jsx_runtime.jsx)(DocumentChangeContext.Provider, {
    value: documentContext,
    children: (0, import_jsx_runtime.jsx)(ChangeList, {
      diff,
      schemaType
    })
  });
}
var changesInspector = {
  name: HISTORY_INSPECTOR_NAME,
  useMenuItem: () => {
    const {
      features
    } = useDeskTool();
    return {
      hidden: !features.reviewChanges,
      icon: RestoreIcon,
      title: "Review changes"
    };
  },
  component: ChangesInspector,
  onClose: (_ref39) => {
    let {
      params
    } = _ref39;
    return {
      params: {
        ...params,
        since: void 0
      }
    };
  },
  onOpen: (_ref40) => {
    let {
      params
    } = _ref40;
    return {
      params: {
        ...params,
        since: "@lastPublished"
      }
    };
  }
};
var documentActions = [PublishAction, UnpublishAction, DiscardChangesAction, DuplicateAction, DeleteAction, HistoryRestoreAction];
var documentBadges = [LiveEditBadge];
var deskTool = definePlugin((options) => ({
  name: "@sanity/desk-tool",
  document: {
    actions: (prevActions) => {
      const actions = prevActions.slice(0);
      for (const action of documentActions) {
        if (!actions.includes(action))
          actions.push(action);
      }
      return actions;
    },
    badges: (prevBadges) => {
      const badges = prevBadges.slice(0);
      for (const badge of documentBadges) {
        if (!badges.includes(badge))
          badges.push(badge);
      }
      return badges;
    },
    inspectors: [validationInspector, changesInspector]
  },
  tools: [{
    name: (options == null ? void 0 : options.name) || "desk",
    title: (options == null ? void 0 : options.title) || "Desk",
    icon: (options == null ? void 0 : options.icon) || MasterDetailIcon,
    component: (0, import_react.lazy)(() => import("./index-0e4a6ec2-ESMXDZHK.js").then(function(n) {
      return n.index;
    })),
    canHandleIntent: (intent, params) => {
      return Boolean(intent === "edit" && params.id || intent === "create" && params.type || intent === "create" && params.template);
    },
    getIntentState,
    options,
    router
  }]
}));
function getInspectorItems(_ref41) {
  let {
    currentInspector,
    hasValue,
    inspectors,
    inspectorMenuItems
  } = _ref41;
  return inspectors.map((inspector, index) => {
    var _a2;
    const menuItem = inspectorMenuItems[index];
    if (!menuItem || menuItem.hidden)
      return null;
    return {
      action: "".concat(INSPECT_ACTION_PREFIX).concat(inspector.name),
      group: menuItem.showAsAction ? void 0 : "inspectors",
      icon: menuItem.icon,
      isDisabled: !hasValue,
      selected: (currentInspector == null ? void 0 : currentInspector.name) === inspector.name,
      shortcut: (_a2 = menuItem.hotkeys) == null ? void 0 : _a2.join("+"),
      showAsAction: menuItem.showAsAction,
      title: menuItem.title,
      tone: menuItem.tone
    };
  }).filter(Boolean);
}
function getInspectItem(_ref42) {
  let {
    hasValue
  } = _ref42;
  return {
    action: "inspect",
    group: "inspectors",
    title: "Inspect",
    icon: BinaryDocumentIcon,
    isDisabled: !hasValue,
    shortcut: "Ctrl+Alt+I"
  };
}
function getProductionPreviewItem(_ref43) {
  let {
    previewUrl
  } = _ref43;
  if (!previewUrl)
    return null;
  return {
    action: "production-preview",
    group: "links",
    title: "Open preview",
    icon: EarthAmericasIcon,
    shortcut: "Ctrl+Alt+O"
  };
}
function getMenuItems(params) {
  const inspectorItems = getInspectorItems(params);
  const items = [
    // Get production preview item
    getProductionPreviewItem(params)
  ].filter(Boolean);
  return [
    ...inspectorItems,
    // TODO: convert to inspector or document view?
    getInspectItem(params),
    ...items
  ];
}
var isSanityDocument = (value) => isRecord$2(value) && typeof value._id === "string" && typeof value._type === "string";
function usePreviewUrl(value) {
  const [previewUrl, setPreviewUrl] = (0, import_react.useState)(void 0);
  const [error, setError] = (0, import_react.useState)(null);
  const {
    resolveProductionUrl
  } = useSource().document;
  const value$ = useAsObservable(value);
  if (error)
    throw error;
  (0, import_react.useEffect)(() => {
    value$.pipe(
      // this so that the preview URL isn't fetched on every keystroke
      debounceTime(500),
      switchMap((document2) => isSanityDocument(document2) ? from(resolveProductionUrl({
        document: document2
      })) : of(void 0)),
      catchError((e) => {
        const message = isRecord$2(e) && typeof e.message === "string" ? e.message : "Unknown error";
        throw new Error("An error was thrown while trying to get your preview url: ".concat(message));
      })
    ).subscribe({
      next: setPreviewUrl,
      error: setError
    });
  }, [resolveProductionUrl, value$]);
  return previewUrl;
}
function getInitialValueTemplateOpts(templates, opts) {
  const payload = opts.panePayload || {};
  const structureNodeTemplate = opts.templateName;
  if (opts.urlTemplate && structureNodeTemplate && structureNodeTemplate !== opts.urlTemplate) {
    console.warn('Conflicting templates: URL says "'.concat(opts.urlTemplate, '", structure node says "').concat(structureNodeTemplate, '". Using "').concat(structureNodeTemplate, '".'));
  }
  const template = structureNodeTemplate || opts.urlTemplate;
  const typeTemplates = templates.filter((t) => t.schemaType === opts.documentType);
  const templateParams = {
    ...opts.templateParams,
    ...typeof payload === "object" ? payload || {} : {}
  };
  let templateName = template;
  if (!template && typeTemplates.length === 1) {
    templateName = typeTemplates[0].id;
  }
  return {
    templateName,
    templateParams
  };
}
var InspectorMenuItem = (0, import_react.memo)(function InspectorMenuItem2(props) {
  const {
    documentId,
    documentType,
    index,
    setMenuItem,
    useMenuItem: useMenuItem2
  } = props;
  const node = useUnique(useMenuItem2({
    documentId,
    documentType
  }));
  (0, import_react.useEffect)(() => {
    setMenuItem(index, node);
  }, [index, node, setMenuItem]);
  return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, {});
});
function DocumentInspectorMenuItemsResolver(props) {
  const {
    documentId,
    documentType,
    inspectors,
    onMenuItems
  } = props;
  const len = inspectors.length;
  const lenRef = (0, import_react.useRef)(len);
  const [menuItems, setMenuItems] = (0, import_react.useState)(() => Array.from(new Array(len)));
  const menuItemsRef = (0, import_react.useRef)(menuItems);
  (0, import_react.useEffect)(() => {
    if (lenRef.current !== len) {
      const newFieldActions = Array.from(new Array(len));
      for (let i = 0; i < len; i++) {
        newFieldActions[i] = menuItemsRef.current[i];
      }
      lenRef.current = len;
      setMenuItems(() => {
        menuItemsRef.current = newFieldActions;
        return newFieldActions;
      });
    }
  }, [len]);
  const setMenuItem = (0, import_react.useCallback)((index, node) => {
    setMenuItems((prev) => {
      const next = [...prev];
      next[index] = node;
      menuItemsRef.current = next;
      return next;
    });
  }, []);
  (0, import_react.useEffect)(() => {
    onMenuItems(menuItems.filter(Boolean));
  }, [menuItems, onMenuItems]);
  return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, {
    children: inspectors.map((inspector, inspectorIndex) => inspector.useMenuItem && (0, import_jsx_runtime.jsx)(InspectorMenuItem, {
      documentId,
      documentType,
      index: inspectorIndex,
      setMenuItem,
      useMenuItem: inspector.useMenuItem
    }, inspector.name))
  });
}
var DocumentPaneProvider = (0, import_react.memo)((props) => {
  const {
    children,
    index,
    pane,
    paneKey
  } = props;
  const schema = useSchema();
  const templates = useTemplates();
  const {
    actions: documentActions2,
    badges: documentBadges2,
    unstable_fieldActions: fieldActionsResolver,
    unstable_languageFilter: languageFilterResolver,
    inspectors: inspectorsResolver
  } = useSource().document;
  const presenceStore = usePresenceStore();
  const paneRouter = usePaneRouter();
  const setPaneParams = paneRouter.setParams;
  const {
    features
  } = useDeskTool();
  const {
    push: pushToast
  } = useToast();
  const {
    options,
    menuItemGroups = DEFAULT_MENU_ITEM_GROUPS,
    title = null,
    views: viewsProp = []
  } = pane;
  const paneOptions = useUnique(options);
  const documentIdRaw = paneOptions.id;
  const documentId = getPublishedId(documentIdRaw);
  const documentType = options.type;
  const params = useUnique(paneRouter.params) || EMPTY_PARAMS;
  const panePayload = useUnique(paneRouter.payload);
  const {
    templateName,
    templateParams
  } = (0, import_react.useMemo)(() => getInitialValueTemplateOpts(templates, {
    documentType,
    templateName: paneOptions.template,
    templateParams: paneOptions.templateParameters,
    panePayload,
    urlTemplate: params.template
  }), [documentType, paneOptions, params, panePayload, templates]);
  const initialValueRaw = useInitialValue({
    documentId,
    documentType,
    templateName,
    templateParams
  });
  const initialValue = useUnique(initialValueRaw);
  const {
    patch
  } = useDocumentOperation(documentId, documentType);
  const editState = useEditState(documentId, documentType);
  const {
    validation: validationRaw
  } = useValidationStatus(documentId, documentType);
  const connectionState = useConnectionState(documentId, documentType);
  const schemaType = schema.get(documentType);
  const value = (editState == null ? void 0 : editState.draft) || (editState == null ? void 0 : editState.published) || initialValue.value;
  const [inspectorMenuItems, setInspectorMenuItems] = (0, import_react.useState)([]);
  const actions = (0, import_react.useMemo)(() => documentActions2({
    schemaType: documentType,
    documentId
  }), [documentActions2, documentId, documentType]);
  const badges = (0, import_react.useMemo)(() => documentBadges2({
    schemaType: documentType,
    documentId
  }), [documentBadges2, documentId, documentType]);
  const languageFilter = (0, import_react.useMemo)(() => languageFilterResolver({
    schemaType: documentType,
    documentId
  }), [documentId, documentType, languageFilterResolver]);
  const validation = useUnique(validationRaw);
  const views2 = useUnique(viewsProp);
  const [focusPath, setFocusPath] = (0, import_react.useState)(() => params.path ? fromString(params.path) : []);
  const activeViewId = params.view || views2[0] && views2[0].id || null;
  const [timelineMode, setTimelineMode] = (0, import_react.useState)("closed");
  const [timelineError, setTimelineError] = (0, import_react.useState)(null);
  const timelineStore = useTimelineStore({
    documentId,
    documentType,
    onError: setTimelineError,
    rev: params.rev,
    since: params.since
  });
  const onOlderRevision = useTimelineSelector(timelineStore, (state2) => state2.onOlderRevision);
  const revTime = useTimelineSelector(timelineStore, (state2) => state2.revTime);
  const sinceAttributes = useTimelineSelector(timelineStore, (state2) => state2.sinceAttributes);
  const timelineDisplayed = useTimelineSelector(timelineStore, (state2) => state2.timelineDisplayed);
  const timelineReady = useTimelineSelector(timelineStore, (state2) => state2.timelineReady);
  const previewUrl = usePreviewUrl(value);
  const [presence, setPresence] = (0, import_react.useState)([]);
  (0, import_react.useEffect)(() => {
    const subscription = presenceStore.documentPresence(documentId).subscribe((nextPresence) => {
      setPresence(nextPresence);
    });
    return () => {
      subscription.unsubscribe();
    };
  }, [documentId, presenceStore]);
  const inspectors = (0, import_react.useMemo)(() => inspectorsResolver({
    documentId,
    documentType
  }), [documentId, documentType, inspectorsResolver]);
  const [inspectorName, setInspectorName] = (0, import_react.useState)(() => params.inspect || null);
  const inspectParamRef = (0, import_react.useRef)(params.inspect);
  (0, import_react.useEffect)(() => {
    if (inspectParamRef.current !== params.inspect) {
      inspectParamRef.current = params.inspect;
      setInspectorName(params.inspect || null);
    }
  }, [params.inspect]);
  const currentInspector = inspectors == null ? void 0 : inspectors.find((i) => i.name === inspectorName);
  const resolvedChangesInspector = inspectors.find((i) => i.name === HISTORY_INSPECTOR_NAME);
  const changesOpen = (currentInspector == null ? void 0 : currentInspector.name) === HISTORY_INSPECTOR_NAME;
  const hasValue = Boolean(value);
  const menuItems = (0, import_react.useMemo)(() => getMenuItems({
    currentInspector,
    features,
    hasValue,
    inspectorMenuItems,
    inspectors,
    previewUrl
  }), [currentInspector, features, hasValue, inspectorMenuItems, inspectors, previewUrl]);
  const inspectOpen = params.inspect === "on";
  const compareValue = changesOpen ? sinceAttributes : (editState == null ? void 0 : editState.published) || null;
  const fieldActions = (0, import_react.useMemo)(() => schemaType ? fieldActionsResolver({
    documentId,
    documentType,
    schemaType
  }) : [], [documentId, documentType, fieldActionsResolver, schemaType]);
  const ready = connectionState === "connected" && editState.ready && (timelineReady || !!timelineError);
  const displayed = (0, import_react.useMemo)(() => onOlderRevision ? timelineDisplayed || {
    _id: value._id,
    _type: value._type
  } : value, [onOlderRevision, timelineDisplayed, value]);
  const setTimelineRange = (0, import_react.useCallback)((newSince, newRev) => {
    setPaneParams({
      ...params,
      since: newSince,
      rev: newRev || void 0
    });
  }, [params, setPaneParams]);
  const handleFocus = (0, import_react.useCallback)((nextFocusPath) => {
    setFocusPath(nextFocusPath);
    presenceStore.setLocation([{
      type: "document",
      documentId,
      path: nextFocusPath,
      lastActiveAt: (/* @__PURE__ */ new Date()).toISOString()
    }]);
  }, [documentId, presenceStore, setFocusPath]);
  const handleBlur = (0, import_react.useCallback)((blurredPath) => {
    setFocusPath([]);
  }, [setFocusPath]);
  const patchRef = (0, import_react.useRef)(() => {
    throw new Error("Nope");
  });
  patchRef.current = (event) => {
    patch.execute(toMutationPatches(event.patches), initialValue.value);
  };
  const handleChange = (0, import_react.useCallback)((event) => patchRef.current(event), []);
  const closeInspector = (0, import_react.useCallback)((closeInspectorName) => {
    var _a2, _b2, _c2, _d2;
    const inspector = closeInspectorName && inspectors.find((i) => i.name === closeInspectorName);
    if (closeInspectorName && !inspector) {
      console.warn('No inspector named "'.concat(closeInspectorName, '"'));
      return;
    }
    if (!currentInspector) {
      return;
    }
    if (inspector) {
      const result = (_b2 = (_a2 = inspector.onClose) == null ? void 0 : _a2.call(inspector, {
        params
      })) != null ? _b2 : {
        params
      };
      setInspectorName(null);
      inspectParamRef.current = void 0;
      setPaneParams({
        ...result.params,
        inspect: void 0
      });
      return;
    }
    if (currentInspector) {
      const result = (_d2 = (_c2 = currentInspector.onClose) == null ? void 0 : _c2.call(currentInspector, {
        params
      })) != null ? _d2 : {
        params
      };
      setInspectorName(null);
      inspectParamRef.current = void 0;
      setPaneParams({
        ...result.params,
        inspect: void 0
      });
    }
  }, [currentInspector, inspectors, params, setPaneParams]);
  const openInspector = (0, import_react.useCallback)((nextInspectorName, paneParams) => {
    var _a2, _b2, _c2, _d2;
    const nextInspector = inspectors.find((i) => i.name === nextInspectorName);
    if (!nextInspector) {
      console.warn('No inspector named "'.concat(nextInspectorName, '"'));
      return;
    }
    if ((currentInspector == null ? void 0 : currentInspector.name) === nextInspector.name) {
      setPaneParams({
        ...params,
        ...paneParams,
        inspect: nextInspector.name
      });
      return;
    }
    let currentParams = params;
    if (currentInspector) {
      const closeResult = (_b2 = (_a2 = nextInspector.onClose) == null ? void 0 : _a2.call(nextInspector, {
        params: currentParams
      })) != null ? _b2 : {
        params: currentParams
      };
      currentParams = closeResult.params;
    }
    const result = (_d2 = (_c2 = nextInspector.onOpen) == null ? void 0 : _c2.call(nextInspector, {
      params: currentParams
    })) != null ? _d2 : {
      params: currentParams
    };
    setInspectorName(nextInspector.name);
    inspectParamRef.current = nextInspector.name;
    setPaneParams({
      ...result.params,
      ...paneParams,
      inspect: nextInspector.name
    });
  }, [currentInspector, inspectors, params, setPaneParams]);
  const handleHistoryClose = (0, import_react.useCallback)(() => {
    if (resolvedChangesInspector) {
      closeInspector(resolvedChangesInspector.name);
    }
  }, [closeInspector, resolvedChangesInspector]);
  const handleHistoryOpen = (0, import_react.useCallback)(() => {
    if (!features.reviewChanges) {
      return;
    }
    if (resolvedChangesInspector) {
      openInspector(resolvedChangesInspector.name);
    }
  }, [features.reviewChanges, openInspector, resolvedChangesInspector]);
  const handlePaneClose = (0, import_react.useCallback)(() => paneRouter.closeCurrent(), [paneRouter]);
  const handlePaneSplit = (0, import_react.useCallback)(() => paneRouter.duplicateCurrent(), [paneRouter]);
  const toggleLegacyInspect = (0, import_react.useCallback)(function() {
    let toggle = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !inspectOpen;
    if (toggle) {
      setPaneParams({
        ...params,
        inspect: "on"
      });
    } else {
      setPaneParams((0, import_omit.default)(params, "inspect"));
    }
  }, [inspectOpen, params, setPaneParams]);
  const handleMenuAction = (0, import_react.useCallback)((item) => {
    if (item.action === "production-preview" && previewUrl) {
      window.open(previewUrl);
      return true;
    }
    if (item.action === "inspect") {
      toggleLegacyInspect(true);
      return true;
    }
    if (item.action === "reviewChanges") {
      handleHistoryOpen();
      return true;
    }
    if (typeof item.action === "string" && item.action.startsWith(INSPECT_ACTION_PREFIX)) {
      const nextInspectorName = item.action.slice(INSPECT_ACTION_PREFIX.length);
      const nextInspector = inspectors.find((i) => i.name === nextInspectorName);
      if (nextInspector) {
        if (nextInspector.name === inspectorName) {
          closeInspector(nextInspector.name);
        } else {
          openInspector(nextInspector.name);
        }
        return true;
      }
    }
    return false;
  }, [closeInspector, handleHistoryOpen, inspectorName, inspectors, openInspector, previewUrl, toggleLegacyInspect]);
  const handleKeyUp = (0, import_react.useCallback)((event) => {
    for (const item of menuItems) {
      if (item.shortcut) {
        if ((0, import_is_hotkey.default)(item.shortcut, event)) {
          event.preventDefault();
          event.stopPropagation();
          handleMenuAction(item);
          return;
        }
      }
    }
  }, [handleMenuAction, menuItems]);
  const handleLegacyInspectClose = (0, import_react.useCallback)(() => toggleLegacyInspect(false), [toggleLegacyInspect]);
  const [openPath, onSetOpenPath] = (0, import_react.useState)([]);
  const [fieldGroupState, onSetFieldGroupState] = (0, import_react.useState)();
  const [collapsedPaths, onSetCollapsedPath] = (0, import_react.useState)();
  const [collapsedFieldSets, onSetCollapsedFieldSets] = (0, import_react.useState)();
  const handleOnSetCollapsedPath = (0, import_react.useCallback)((path, collapsed) => {
    onSetCollapsedPath((prevState) => setAtPath(prevState, path, collapsed));
  }, []);
  const handleOnSetCollapsedFieldSet = (0, import_react.useCallback)((path, collapsed) => {
    onSetCollapsedFieldSets((prevState) => setAtPath(prevState, path, collapsed));
  }, []);
  const handleSetActiveFieldGroup = (0, import_react.useCallback)((path, groupName) => onSetFieldGroupState((prevState) => setAtPath(prevState, path, groupName)), []);
  const requiredPermission = value._createdAt ? "update" : "create";
  const liveEdit = Boolean(schemaType == null ? void 0 : schemaType.liveEdit);
  const docId = value._id ? value._id : "dummy-id";
  const docPermissionsInput = (0, import_react.useMemo)(() => {
    return {
      ...value,
      _id: liveEdit ? getPublishedId(docId) : getDraftId(docId)
    };
  }, [liveEdit, value, docId]);
  const [permissions, isPermissionsLoading] = useDocumentValuePermissions({
    document: docPermissionsInput,
    permission: requiredPermission
  });
  const isNonExistent = !(value == null ? void 0 : value._id);
  const readOnly = (0, import_react.useMemo)(() => {
    var _a2;
    const hasNoPermission = !isPermissionsLoading && !(permissions == null ? void 0 : permissions.granted);
    const updateActionDisabled = !isActionEnabled(schemaType, "update");
    const createActionDisabled = isNonExistent && !isActionEnabled(schemaType, "create");
    const reconnecting = connectionState === "reconnecting";
    const isLocked = (_a2 = editState.transactionSyncLock) == null ? void 0 : _a2.enabled;
    return !ready || revTime !== null || hasNoPermission || updateActionDisabled || createActionDisabled || reconnecting || isLocked;
  }, [connectionState, isNonExistent, isPermissionsLoading, permissions == null ? void 0 : permissions.granted, ready, revTime, schemaType, editState.transactionSyncLock]);
  const formState = useFormState(schemaType, {
    value: displayed,
    readOnly,
    comparisonValue: compareValue,
    focusPath,
    openPath,
    collapsedPaths,
    presence,
    validation,
    collapsedFieldSets,
    fieldGroupState,
    changesOpen
  });
  const formStateRef = (0, import_react.useRef)(formState);
  formStateRef.current = formState;
  const setOpenPath = (0, import_react.useCallback)((path) => {
    const ops = getExpandOperations(formStateRef.current, path);
    ops.forEach((op) => {
      if (op.type === "expandPath") {
        onSetCollapsedPath((prevState) => setAtPath(prevState, op.path, false));
      }
      if (op.type === "expandFieldSet") {
        onSetCollapsedFieldSets((prevState) => setAtPath(prevState, op.path, false));
      }
      if (op.type === "setSelectedGroup") {
        onSetFieldGroupState((prevState) => setAtPath(prevState, op.path, op.groupName));
      }
    });
    onSetOpenPath(path);
  }, [formStateRef]);
  const documentPane = {
    actions,
    activeViewId,
    badges,
    changesOpen,
    closeInspector,
    collapsedFieldSets,
    collapsedPaths,
    compareValue,
    connectionState,
    displayed,
    documentId,
    documentIdRaw,
    documentType,
    editState,
    fieldActions,
    focusPath,
    inspector: currentInspector || null,
    inspectors,
    menuItems,
    onBlur: handleBlur,
    onChange: handleChange,
    onFocus: handleFocus,
    onPathOpen: setOpenPath,
    onHistoryClose: handleHistoryClose,
    onHistoryOpen: handleHistoryOpen,
    onInspectClose: handleLegacyInspectClose,
    onKeyUp: handleKeyUp,
    onMenuAction: handleMenuAction,
    onPaneClose: handlePaneClose,
    onPaneSplit: handlePaneSplit,
    onSetActiveFieldGroup: handleSetActiveFieldGroup,
    onSetCollapsedPath: handleOnSetCollapsedPath,
    onSetCollapsedFieldSet: handleOnSetCollapsedFieldSet,
    openInspector,
    index,
    inspectOpen,
    validation,
    menuItemGroups: menuItemGroups || [],
    paneKey,
    previewUrl,
    ready,
    schemaType,
    isPermissionsLoading,
    permissions,
    setTimelineMode,
    setTimelineRange,
    timelineError,
    timelineMode,
    timelineStore,
    title,
    value,
    views: views2,
    formState,
    unstable_languageFilter: languageFilter
  };
  (0, import_react.useEffect)(() => {
    if (connectionState === "reconnecting") {
      pushToast({
        id: "sanity/desk/reconnecting",
        status: "warning",
        title: (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, {
          children: "Connection lost. Reconnecting…"
        })
      });
    }
  }, [connectionState, pushToast]);
  (0, import_react.useEffect)(() => {
    var _a2;
    if (ready && params.path) {
      const {
        path,
        ...restParams
      } = params;
      const pathFromUrl = resolveKeyedPath((_a2 = formStateRef.current) == null ? void 0 : _a2.value, fromString(path));
      setFocusPath(pathFromUrl);
      setOpenPath(pathFromUrl);
      paneRouter.setParams(restParams);
    }
  }, [params, documentId, setOpenPath, ready, paneRouter]);
  const [rootFieldActionNodes, setRootFieldActionNodes] = (0, import_react.useState)([]);
  return (0, import_jsx_runtime.jsxs)(DocumentPaneContext.Provider, {
    value: documentPane,
    children: [inspectors.length > 0 && (0, import_jsx_runtime.jsx)(DocumentInspectorMenuItemsResolver, {
      documentId,
      documentType,
      inspectors,
      onMenuItems: setInspectorMenuItems
    }), fieldActions.length > 0 && schemaType && (0, import_jsx_runtime.jsx)(FieldActionsResolver, {
      actions: fieldActions,
      documentId,
      documentType,
      onActions: setRootFieldActionNodes,
      path: EMPTY_ARRAY$7,
      schemaType
    }), (0, import_jsx_runtime.jsx)(FieldActionsProvider, {
      actions: rootFieldActionNodes,
      path: EMPTY_ARRAY$7,
      children
    })]
  });
});
DocumentPaneProvider.displayName = "DocumentPaneProvider";
var __defProp$e = Object.defineProperty;
var __defNormalProp$e = (obj, key, value) => key in obj ? __defProp$e(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;
var __publicField$e = (obj, key, value) => {
  __defNormalProp$e(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var SerializeError = class extends Error {
  constructor(message, parentPath, pathSegment, hint) {
    super(message);
    __publicField$e(this, "path");
    __publicField$e(this, "helpId");
    const segment = typeof pathSegment === "undefined" ? "<unknown>" : "".concat(pathSegment);
    this.path = (parentPath || []).concat(hint ? "".concat(segment, " (").concat(hint, ")") : segment);
  }
  withHelpUrl(id) {
    this.helpId = id;
    return this;
  }
};
var HELP_URL = ((HELP_URL2) => {
  HELP_URL2["ID_REQUIRED"] = "structure-node-id-required";
  HELP_URL2["TITLE_REQUIRED"] = "structure-title-required";
  HELP_URL2["FILTER_REQUIRED"] = "structure-filter-required";
  HELP_URL2["INVALID_LIST_ITEM"] = "structure-invalid-list-item";
  HELP_URL2["COMPONENT_REQUIRED"] = "structure-view-component-required";
  HELP_URL2["DOCUMENT_ID_REQUIRED"] = "structure-document-id-required";
  HELP_URL2["DOCUMENT_TYPE_REQUIRED"] = "structure-document-type-required";
  HELP_URL2["SCHEMA_TYPE_REQUIRED"] = "structure-schema-type-required";
  HELP_URL2["SCHEMA_TYPE_NOT_FOUND"] = "structure-schema-type-not-found";
  HELP_URL2["LIST_ITEMS_MUST_BE_ARRAY"] = "structure-list-items-must-be-array";
  HELP_URL2["QUERY_PROVIDED_FOR_FILTER"] = "structure-query-provided-for-filter";
  HELP_URL2["ACTION_OR_INTENT_REQUIRED"] = "structure-action-or-intent-required";
  HELP_URL2["LIST_ITEM_IDS_MUST_BE_UNIQUE"] = "structure-list-item-ids-must-be-unique";
  HELP_URL2["ACTION_AND_INTENT_MUTUALLY_EXCLUSIVE"] = "structure-action-and-intent-mutually-exclusive";
  return HELP_URL2;
})(HELP_URL || {});
var IMPLICIT_FIELDS = ["_id", "_type", "_createdAt", "_updatedAt", "_rev"];
function joinReferences(schemaType, path) {
  const [head, ...tail] = path;
  if (!("fields" in schemaType)) {
    return "";
  }
  const schemaField = schemaType.fields.find((field) => field.name === head);
  if (!schemaField) {
    if (!IMPLICIT_FIELDS.includes(head)) {
      console.warn('The current ordering config targeted the nonexistent field "%s" on schema type "%s". It should be one of %o', head, schemaType.name, schemaType.fields.map((field) => field.name));
    }
    return "";
  }
  if ("to" in schemaField.type && schemaField.type.name === "reference") {
    const refTypes = schemaField.type.to;
    return "".concat(head, "->{").concat(refTypes.map((refType) => joinReferences(refType, tail)).join(","), "}");
  }
  const tailFields = tail.length > 0 && joinReferences(schemaField.type, tail);
  const tailWrapper = tailFields ? "{".concat(tailFields, "}") : "";
  return tail.length > 0 ? "".concat(head).concat(tailWrapper) : head;
}
function getExtendedProjection(schemaType, orderBy) {
  return orderBy.map((ordering) => joinReferences(schemaType, ordering.field.split("."))).join(", ");
}
var ORDER_BY_UPDATED_AT = {
  title: "Last edited",
  name: "lastEditedDesc",
  by: [{
    field: "_updatedAt",
    direction: "desc"
  }]
};
var ORDER_BY_CREATED_AT = {
  title: "Created",
  name: "lastCreatedDesc",
  by: [{
    field: "_createdAt",
    direction: "desc"
  }]
};
var DEFAULT_SELECTED_ORDERING_OPTION = ORDER_BY_UPDATED_AT;
var DEFAULT_ORDERING_OPTIONS = [
  ORDER_BY_UPDATED_AT,
  // _updatedAt
  ORDER_BY_CREATED_AT
  // _createdAt
];
var __defProp$d = Object.defineProperty;
var __defNormalProp$d = (obj, key, value) => key in obj ? __defProp$d(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;
var __publicField$d = (obj, key, value) => {
  __defNormalProp$d(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
function maybeSerializeMenuItem(item, index, path) {
  return item instanceof MenuItemBuilder ? item.serialize({
    path,
    index
  }) : item;
}
var MenuItemBuilder = class _MenuItemBuilder {
  constructor(_context, spec) {
    this._context = _context;
    __publicField$d(this, "spec");
    this.spec = spec ? spec : {};
  }
  /**
   * Set menu item action
   * @param action - menu item action. See {@link MenuItemActionType}
   * @returns menu item builder based on action provided. See {@link MenuItemBuilder}
   */
  action(action) {
    return this.clone({
      action
    });
  }
  /**
   * Get menu item action
   * @returns menu item builder action. See {@link PartialMenuItem}
   */
  getAction() {
    return this.spec.action;
  }
  /**
   * Set menu item intent
   * @param intent - menu item intent. See {@link Intent}
   * @returns menu item builder based on intent provided. See {@link MenuItemBuilder}
   */
  intent(intent) {
    return this.clone({
      intent
    });
  }
  /**
   * Get menu item intent
   * @returns menu item intent. See {@link PartialMenuItem}
   */
  getIntent() {
    return this.spec.intent;
  }
  /**
   * Set menu item title
   * @param title - menu item title
   * @returns menu item builder based on title provided. See {@link MenuItemBuilder}
   */
  title(title) {
    return this.clone({
      title
    });
  }
  /**
   * Get menu item title
   * @returns menu item title
   */
  getTitle() {
    return this.spec.title;
  }
  /**
   * Set menu item group
   * @param group - menu item group
   * @returns menu item builder based on group provided. See {@link MenuItemBuilder}
   */
  group(group) {
    return this.clone({
      group
    });
  }
  /**
   * Get menu item group
   * @returns menu item group. See {@link PartialMenuItem}
   */
  getGroup() {
    return this.spec.group;
  }
  /**
   * Set menu item icon
   * @param icon - menu item icon
   * @returns menu item builder based on icon provided. See {@link MenuItemBuilder}
   */
  icon(icon) {
    return this.clone({
      icon
    });
  }
  /**
   * Get menu item icon
   * @returns menu item icon. See {@link PartialMenuItem}
   */
  getIcon() {
    return this.spec.icon;
  }
  /**
   * Set menu item parameters
   * @param params - menu item parameters. See {@link MenuItemParamsType}
   * @returns menu item builder based on parameters provided. See {@link MenuItemBuilder}
   */
  params(params) {
    return this.clone({
      params
    });
  }
  /**
   * Get meny item parameters
   * @returns menu item parameters. See {@link PartialMenuItem}
   */
  getParams() {
    return this.spec.params;
  }
  /**
   * Set menu item to show as action
   * @param showAsAction - determine if menu item should show as action
   * @returns menu item builder based on if it should show as action. See {@link MenuItemBuilder}
   */
  showAsAction() {
    let showAsAction = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
    return this.clone({
      showAsAction: Boolean(showAsAction)
    });
  }
  /**
   * Check if menu item should show as action
   * @returns true if menu item should show as action, false if not. See {@link PartialMenuItem}
   */
  getShowAsAction() {
    return this.spec.showAsAction;
  }
  /** Serialize menu item builder
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns menu item node based on path provided in options. See {@link MenuItem}
   */
  serialize() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      path: []
    };
    const {
      title,
      action,
      intent
    } = this.spec;
    if (!title) {
      const hint = typeof action === "string" ? 'action: "'.concat(action, '"') : void 0;
      throw new SerializeError("`title` is required for menu item", options.path, options.index, hint).withHelpUrl(HELP_URL.TITLE_REQUIRED);
    }
    if (!action && !intent) {
      throw new SerializeError("`action` or `intent` required for menu item with title ".concat(this.spec.title), options.path, options.index, '"'.concat(title, '"')).withHelpUrl(HELP_URL.ACTION_OR_INTENT_REQUIRED);
    }
    if (intent && action) {
      throw new SerializeError("cannot set both `action` AND `intent`", options.path, options.index, '"'.concat(title, '"')).withHelpUrl(HELP_URL.ACTION_AND_INTENT_MUTUALLY_EXCLUSIVE);
    }
    return {
      ...this.spec,
      title
    };
  }
  /** Clone menu item builder
   * @param withSpec - menu item options. See {@link PartialMenuItem}
   * @returns menu item builder based on context and spec provided. See {@link MenuItemBuilder}
   */
  clone(withSpec) {
    const builder = new _MenuItemBuilder(this._context);
    builder.spec = {
      ...this.spec,
      ...withSpec || {}
    };
    return builder;
  }
};
function getOrderingMenuItem(context, ordering, extendedProjection) {
  return new MenuItemBuilder(context).group("sorting").title("Sort by ".concat(ordering.title)).icon(SortIcon).action("setSortOrder").params({
    by: ordering.by,
    extendedProjection
  });
}
function getOrderingMenuItemsForSchemaType(context, typeName) {
  const {
    schema
  } = context;
  const type = typeof typeName === "string" ? schema.get(typeName) : typeName;
  if (!type || !("orderings" in type)) {
    return [];
  }
  return (type.orderings ? type.orderings.concat(DEFAULT_ORDERING_OPTIONS) : DEFAULT_ORDERING_OPTIONS).map((ordering) => getOrderingMenuItem(context, ordering, getExtendedProjection(type, ordering.by)));
}
var __defProp$c = Object.defineProperty;
var __defNormalProp$c = (obj, key, value) => key in obj ? __defProp$c(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;
var __publicField$c = (obj, key, value) => {
  __defNormalProp$c(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
function maybeSerializeMenuItemGroup(item, index, path) {
  return item instanceof MenuItemGroupBuilder ? item.serialize({
    path,
    index
  }) : item;
}
var MenuItemGroupBuilder = class _MenuItemGroupBuilder {
  constructor(_context, spec) {
    this._context = _context;
    __publicField$c(this, "_id");
    __publicField$c(this, "_title");
    this._id = spec ? spec.id : "";
    this._title = spec ? spec.title : "";
  }
  /**
   * Set menu item group ID
   * @param id - menu item group ID
   * @returns menu item group builder based on ID provided. See {@link MenuItemGroupBuilder}
   */
  id(id) {
    return new _MenuItemGroupBuilder(this._context, {
      id,
      title: this._title
    });
  }
  /**
   * Get menu item group ID
   * @returns menu item group ID
   */
  getId() {
    return this._id;
  }
  /**
   * Set menu item group title
   * @param title - menu item group title
   * @returns menu item group builder based on title provided. See {@link MenuItemGroupBuilder}
   */
  title(title) {
    return new _MenuItemGroupBuilder(this._context, {
      id: this._id,
      title
    });
  }
  /**
   * Get menu item group title
   * @returns menu item group title
   */
  getTitle() {
    return this._title;
  }
  /**
   * Serialize menu item group builder
   * @param options - serialization options (path). See {@link SerializeOptions}
   * @returns menu item group based on path provided in options. See {@link MenuItemGroup}
   */
  serialize() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      path: []
    };
    const {
      _id,
      _title
    } = this;
    if (!_id) {
      throw new SerializeError("`id` is required for a menu item group", options.path, options.index, _title).withHelpUrl(HELP_URL.ID_REQUIRED);
    }
    if (!_title) {
      throw new SerializeError("`title` is required for a menu item group", options.path, _id).withHelpUrl(HELP_URL.TITLE_REQUIRED);
    }
    return {
      id: _id,
      title: _title
    };
  }
};
var disallowedPattern = /([^A-Za-z0-9-_.])/;
function validateId(id, parentPath, pathSegment) {
  if (typeof id !== "string") {
    throw new SerializeError("Structure node id must be of type string, got ".concat(typeof id), parentPath, pathSegment);
  }
  const [disallowedChar] = id.match(disallowedPattern) || [];
  if (disallowedChar) {
    throw new SerializeError('Structure node id cannot contain character "'.concat(disallowedChar, '"'), parentPath, pathSegment);
  }
  if (id.startsWith("__edit__")) {
    throw new SerializeError("Structure node id cannot start with __edit__", parentPath, pathSegment);
  }
  return id;
}
function getStructureNodeId(title, id) {
  if (id) {
    return id;
  }
  const camelCased = (0, import_camelCase.default)(title);
  return disallowedPattern.test(camelCased) ? (0, import_camelCase.default)((0, import_speakingurl.default)(title)) : camelCased;
}
var __defProp$b = Object.defineProperty;
var __defNormalProp$b = (obj, key, value) => key in obj ? __defProp$b(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;
var __publicField$b = (obj, key, value) => {
  __defNormalProp$b(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var ComponentBuilder = class _ComponentBuilder {
  constructor(spec) {
    __publicField$b(this, "spec");
    this.spec = {
      options: {},
      ...spec ? spec : {}
    };
  }
  /** Set Component ID
   * @param id - component ID
   * @returns component builder based on ID provided
   */
  id(id) {
    return this.clone({
      id
    });
  }
  /** Get ID
   * @returns ID
   */
  getId() {
    return this.spec.id;
  }
  /** Set Component title
   * @param title - component title
   * @returns component builder based on title provided (and ID)
   */
  title(title) {
    return this.clone({
      title,
      id: getStructureNodeId(title, this.spec.id)
    });
  }
  /** Get Component title
   * @returns title
   */
  getTitle() {
    return this.spec.title;
  }
  /** Set Component child
   * @param child - child component
   * @returns component builder based on child component provided
   */
  child(child) {
    return this.clone({
      child
    });
  }
  /** Get Component child
   * @returns child component
   */
  getChild() {
    return this.spec.child;
  }
  /** Set component
   * @param component - user built component
   * @returns component builder based on component provided
   */
  component(component2) {
    return this.clone({
      component: component2
    });
  }
  /** Get Component
   * @returns component
   */
  getComponent() {
    return this.spec.component;
  }
  /** Set Component options
   * @param options - component options
   * @returns component builder based on options provided
   */
  options(options) {
    return this.clone({
      options
    });
  }
  /** Get Component options
   * @returns component options
   */
  getOptions() {
    return this.spec.options || {};
  }
  /** Set Component menu items
   * @param menuItems - component menu items
   * @returns component builder based on menuItems provided
   */
  menuItems(menuItems) {
    return this.clone({
      menuItems
    });
  }
  /** Get Component menu items
   * @returns menu items
   */
  getMenuItems() {
    return this.spec.menuItems;
  }
  /** Set Component menu item groups
   * @param menuItemGroups - component menu item groups
   * @returns component builder based on menuItemGroups provided
   */
  menuItemGroups(menuItemGroups) {
    return this.clone({
      menuItemGroups
    });
  }
  /** Get Component menu item groups
   * @returns menu item groups
   */
  getMenuItemGroups() {
    return this.spec.menuItemGroups;
  }
  /** Serialize component
   * @param options - serialization options
   * @returns component object based on path provided in options
   *
   */
  serialize() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      path: []
    };
    const {
      id,
      title,
      child,
      options: componentOptions,
      component: component2
    } = this.spec;
    if (!id) {
      throw new SerializeError("`id` is required for `component` structure item", options.path, options.index).withHelpUrl(HELP_URL.ID_REQUIRED);
    }
    if (!component2) {
      throw new SerializeError("`component` is required for `component` structure item", options.path, options.index).withHelpUrl(HELP_URL.ID_REQUIRED);
    }
    return {
      id: validateId(id, options.path, options.index),
      title,
      type: "component",
      child,
      component: component2,
      options: componentOptions || {},
      menuItems: (this.spec.menuItems || []).map((item, i) => maybeSerializeMenuItem(item, i, options.path)),
      menuItemGroups: (this.spec.menuItemGroups || []).map((item, i) => maybeSerializeMenuItemGroup(item, i, options.path))
    };
  }
  /** Clone component builder (allows for options overriding)
   * @param withSpec - component builder options
   * @returns cloned builder
   */
  clone(withSpec) {
    const builder = new _ComponentBuilder();
    builder.spec = {
      ...this.spec,
      ...withSpec || {}
    };
    return builder;
  }
};
async function resolveTypeForDocument(getClient, id) {
  const query = "*[_id in [$documentId, $draftId]]._type";
  const documentId = getPublishedId(id);
  const draftId = getDraftId(id);
  const types = await getClient(DEFAULT_STUDIO_CLIENT_OPTIONS).fetch(query, {
    documentId,
    draftId
  }, {
    tag: "structure.resolve-type"
  });
  return types[0];
}
var __defProp$a = Object.defineProperty;
var __defNormalProp$a = (obj, key, value) => key in obj ? __defProp$a(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;
var __publicField$a = (obj, key, value) => {
  __defNormalProp$a(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var GenericViewBuilder = class {
  constructor() {
    __publicField$a(this, "spec", {});
  }
  /** Set generic view ID
   * @param id - generic view ID
   * @returns generic view builder based on ID provided.
   */
  id(id) {
    return this.clone({
      id
    });
  }
  /** Get generic view ID
   * @returns generic view ID
   */
  getId() {
    return this.spec.id;
  }
  /** Set generic view title
   * @param title - generic view title
   * @returns generic view builder based on title provided and (if provided) its ID.
   */
  title(title) {
    return this.clone({
      title,
      id: this.spec.id || (0, import_kebabCase.default)(title)
    });
  }
  /** Get generic view title
   * @returns generic view title
   */
  getTitle() {
    return this.spec.title;
  }
  /** Set generic view icon
   * @param icon - generic view icon
   * @returns generic view builder based on icon provided.
   */
  icon(icon) {
    return this.clone({
      icon
    });
  }
  /** Get generic view icon
   * @returns generic view icon
   */
  getIcon() {
    return this.spec.icon;
  }
  /** Serialize generic view
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns generic view object based on path provided in options. See {@link BaseView}
   */
  serialize() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      path: []
    };
    const {
      id,
      title,
      icon
    } = this.spec;
    if (!id) {
      throw new SerializeError("`id` is required for view item", options.path, options.index).withHelpUrl(HELP_URL.ID_REQUIRED);
    }
    if (!title) {
      throw new SerializeError("`title` is required for view item", options.path, options.index).withHelpUrl(HELP_URL.TITLE_REQUIRED);
    }
    return {
      id: validateId(id, options.path, options.index),
      title,
      icon
    };
  }
};
function isSerializable(view) {
  return typeof view.serialize === "function";
}
function maybeSerializeView(item, index, path) {
  return isSerializable(item) ? item.serialize({
    path,
    index
  }) : item;
}
var __defProp$9 = Object.defineProperty;
var __defNormalProp$9 = (obj, key, value) => key in obj ? __defProp$9(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;
var __publicField$9 = (obj, key, value) => {
  __defNormalProp$9(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var isComponentSpec = (spec) => isRecord$2(spec) && spec.type === "component";
var ComponentViewBuilder = class _ComponentViewBuilder extends GenericViewBuilder {
  constructor(componentOrSpec) {
    const spec = isComponentSpec(componentOrSpec) ? {
      ...componentOrSpec
    } : {
      options: {}
    };
    super();
    __publicField$9(this, "spec");
    this.spec = spec;
    const userComponent = typeof componentOrSpec === "function" ? componentOrSpec : this.spec.component;
    if (userComponent) {
      this.spec = this.component(userComponent).spec;
    }
  }
  /** Set view Component
   * @param component - component view component. See {@link UserViewComponent}
   * @returns component view builder based on component view provided. See {@link ComponentViewBuilder}
   */
  component(component2) {
    return this.clone({
      component: component2
    });
  }
  /** Get view Component
   * @returns Partial component view. See {@link ComponentView}
   */
  getComponent() {
    return this.spec.component;
  }
  /** Set view Component options
   * @param options - component view options
   * @returns component view builder based on options provided. See {@link ComponentViewBuilder}
   */
  options(options) {
    return this.clone({
      options
    });
  }
  /** Get view Component options
   * @returns component view options. See {@link ComponentView}
   */
  getOptions() {
    return this.spec.options || {};
  }
  /** Serialize view Component
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns component view based on path provided in options. See {@link ComponentView}
   *
   */
  serialize() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      path: []
    };
    const base = super.serialize(options);
    const component2 = this.spec.component;
    if (typeof component2 !== "function") {
      throw new SerializeError("`component` is required and must be a function for `component()` view item", options.path, options.index).withHelpUrl(HELP_URL.COMPONENT_REQUIRED);
    }
    return {
      ...base,
      component: component2,
      options: this.spec.options || {},
      type: "component"
    };
  }
  /** Clone Component view builder (allows for options overriding)
   * @param withSpec - partial for component view option. See {@link ComponentView}
   * @returns component view builder. See {@link ComponentViewBuilder}
   */
  clone(withSpec) {
    const builder = new _ComponentViewBuilder();
    builder.spec = {
      ...this.spec,
      ...withSpec || {}
    };
    return builder;
  }
};
var __defProp$8 = Object.defineProperty;
var __defNormalProp$8 = (obj, key, value) => key in obj ? __defProp$8(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;
var __publicField$8 = (obj, key, value) => {
  __defNormalProp$8(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var FormViewBuilder = class _FormViewBuilder extends GenericViewBuilder {
  constructor(spec) {
    super();
    __publicField$8(this, "spec");
    this.spec = {
      id: "editor",
      title: "Editor",
      ...spec ? spec : {}
    };
  }
  /**
   * Serialize Form view builder
   * @param options - Serialize options. See {@link SerializeOptions}
   * @returns form view builder based on path provided in options. See {@link FormView}
   */
  serialize() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      path: []
    };
    return {
      ...super.serialize(options),
      type: "form"
    };
  }
  /**
   * Clone Form view builder (allows for options overriding)
   * @param withSpec - Partial form view builder options. See {@link FormView}
   * @returns form view builder. See {@link FormViewBuilder}
   */
  clone(withSpec) {
    const builder = new _FormViewBuilder();
    builder.spec = {
      ...this.spec,
      ...withSpec || {}
    };
    return builder;
  }
};
var form = (spec) => new FormViewBuilder(spec);
var component = (componentOrSpec) => new ComponentViewBuilder(componentOrSpec);
var views = Object.freeze({
  __proto__: null,
  ComponentViewBuilder,
  FormViewBuilder,
  GenericViewBuilder,
  component,
  form,
  maybeSerializeView
});
var __defProp$7 = Object.defineProperty;
var __defNormalProp$7 = (obj, key, value) => key in obj ? __defProp$7(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;
var __publicField$7 = (obj, key, value) => {
  __defNormalProp$7(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var createDocumentChildResolver = (_ref44) => {
  let {
    resolveDocumentNode,
    getClient
  } = _ref44;
  return async (itemId, _ref45) => {
    let {
      params,
      path
    } = _ref45;
    let type = params.type;
    const parentPath = path.slice(0, path.length - 1);
    const currentSegment = path[path.length - 1];
    if (!type) {
      type = await resolveTypeForDocument(getClient, itemId);
    }
    if (!type) {
      throw new SerializeError("Failed to resolve document, and no type provided in parameters.", parentPath, currentSegment);
    }
    return resolveDocumentNode({
      documentId: itemId,
      schemaType: type
    });
  };
};
var DocumentBuilder = class _DocumentBuilder {
  constructor(_context, spec) {
    this._context = _context;
    __publicField$7(this, "spec");
    this.spec = spec ? spec : {};
  }
  /** Set Document Builder ID
   * @param id - document builder ID
   * @returns document builder based on ID provided. See {@link DocumentBuilder}
   */
  id(id) {
    return this.clone({
      id
    });
  }
  /** Get Document Builder ID
   * @returns document ID. See {@link PartialDocumentNode}
   */
  getId() {
    return this.spec.id;
  }
  /** Set Document title
   * @param title - document title
   * @returns document builder based on title provided (and ID). See {@link DocumentBuilder}
   */
  title(title) {
    return this.clone({
      title,
      id: getStructureNodeId(title, this.spec.id)
    });
  }
  /** Get Document title
   * @returns document title. See {@link PartialDocumentNode}
   */
  getTitle() {
    return this.spec.title;
  }
  /** Set Document child
   * @param child - document child
   * @returns document builder based on child provided. See {@link DocumentBuilder}
   */
  child(child) {
    return this.clone({
      child
    });
  }
  /** Get Document child
   * @returns document child. See {@link PartialDocumentNode}
   */
  getChild() {
    return this.spec.child;
  }
  /** Set Document ID
   * @param documentId - document ID
   * @returns document builder with document based on ID provided. See {@link DocumentBuilder}
   */
  documentId(documentId) {
    const paneId = this.spec.id || documentId;
    return this.clone({
      id: paneId,
      options: {
        ...this.spec.options || {},
        id: documentId
      }
    });
  }
  /** Get Document ID
   * @returns document ID. See {@link DocumentOptions}
   */
  getDocumentId() {
    var _a2;
    return (_a2 = this.spec.options) == null ? void 0 : _a2.id;
  }
  /** Set Document Type
   * @param documentType - document type
   * @returns document builder with document based on type provided. See {@link DocumentBuilder}
   */
  schemaType(documentType) {
    return this.clone({
      options: {
        ...this.spec.options || {},
        type: typeof documentType === "string" ? documentType : documentType.name
      }
    });
  }
  /** Get Document Type
   * @returns document type. See {@link DocumentOptions}
   */
  getSchemaType() {
    var _a2;
    return (_a2 = this.spec.options) == null ? void 0 : _a2.type;
  }
  /** Set Document Template
   * @param templateId - document template ID
   * @param parameters - document template parameters
   * @returns document builder with document based on template provided. See {@link DocumentBuilder}
   */
  initialValueTemplate(templateId, parameters) {
    return this.clone({
      options: {
        ...this.spec.options || {},
        template: templateId,
        templateParameters: parameters
      }
    });
  }
  /** Get Document Template
   * @returns document template. See {@link DocumentOptions}
   */
  getInitialValueTemplate() {
    var _a2;
    return (_a2 = this.spec.options) == null ? void 0 : _a2.template;
  }
  /** Get Document's initial value Template parameters
   * @returns document template parameters. See {@link DocumentOptions}
   */
  getInitialValueTemplateParameters() {
    var _a2;
    return (_a2 = this.spec.options) == null ? void 0 : _a2.templateParameters;
  }
  /** Set Document views
   * @param views - document views. See {@link ViewBuilder} and {@link View}
   * @returns document builder with document based on views provided. See {@link DocumentBuilder}
   */
  views(views2) {
    return this.clone({
      views: views2
    });
  }
  /** Get Document views
   * @returns document views. See {@link ViewBuilder} and {@link View}
   */
  getViews() {
    return this.spec.views || [];
  }
  /** Serialize Document builder
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns document node based on path, index and hint provided in options. See {@link DocumentNode}
   */
  serialize() {
    let {
      path = [],
      index,
      hint
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      path: []
    };
    const urlId = path[index || path.length - 1];
    const id = this.spec.id || urlId && "".concat(urlId) || "";
    const options = {
      id,
      type: void 0,
      template: void 0,
      templateParameters: void 0,
      ...this.spec.options
    };
    if (typeof id !== "string" || !id) {
      throw new SerializeError("`id` is required for document nodes", path, index, hint).withHelpUrl(HELP_URL.ID_REQUIRED);
    }
    if (!options || !options.id) {
      throw new SerializeError("document id (`id`) is required for document nodes", path, id, hint).withHelpUrl(HELP_URL.DOCUMENT_ID_REQUIRED);
    }
    if (!options || !options.type) {
      throw new SerializeError("document type (`schemaType`) is required for document nodes", path, id, hint);
    }
    const views2 = (this.spec.views && this.spec.views.length > 0 ? this.spec.views : [form()]).map((item, i) => maybeSerializeView(item, i, path));
    const viewIds = views2.map((view) => view.id);
    const dupes = (0, import_uniq.default)(viewIds.filter((viewId, i) => viewIds.includes(viewId, i + 1)));
    if (dupes.length > 0) {
      throw new SerializeError("document node has views with duplicate IDs: ".concat(dupes.join(",  ")), path, id, hint);
    }
    return {
      ...this.spec,
      child: this.spec.child || createDocumentChildResolver(this._context),
      id: validateId(id, path, index),
      type: "document",
      options: getDocumentOptions(options),
      views: views2
    };
  }
  /** Clone Document builder
   * @param withSpec - partial document node specification used to extend the cloned builder. See {@link PartialDocumentNode}
   * @returns document builder based on context and spec provided. See {@link DocumentBuilder}
   */
  clone() {
    let withSpec = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const builder = new _DocumentBuilder(this._context);
    const options = {
      ...this.spec.options || {},
      ...withSpec.options || {}
    };
    builder.spec = {
      ...this.spec,
      ...withSpec,
      options
    };
    return builder;
  }
};
function getDocumentOptions(spec) {
  const opts = {
    id: spec.id || "",
    type: spec.type || "*"
  };
  if (spec.template) {
    opts.template = spec.template;
  }
  if (spec.templateParameters) {
    opts.templateParameters = spec.templateParameters;
  }
  return opts;
}
function documentFromEditor(context, spec) {
  let doc = (spec == null ? void 0 : spec.type) ? (
    // Use user-defined document fragment as base if possible
    context.resolveDocumentNode({
      schemaType: spec.type
    })
  ) : (
    // Fall back to plain old document builder
    new DocumentBuilder(context)
  );
  if (!spec)
    return doc;
  const {
    id,
    type,
    template,
    templateParameters
  } = spec.options;
  doc = doc.id(spec.id).documentId(id);
  if (type) {
    doc = doc.schemaType(type);
  }
  if (template) {
    doc = doc.initialValueTemplate(template, templateParameters);
  }
  if (spec.child) {
    doc = doc.child(spec.child);
  }
  return doc;
}
function documentFromEditorWithInitialValue(_ref46, templateId, parameters) {
  let {
    resolveDocumentNode,
    templates
  } = _ref46;
  const template = templates.find((t) => t.id === templateId);
  if (!template) {
    throw new Error('Template with ID "'.concat(templateId, '" not defined'));
  }
  return resolveDocumentNode({
    schemaType: template.schemaType
  }).initialValueTemplate(templateId, parameters);
}
var layoutOptions = ["default", "card", "media", "detail", "block"];
var DEFAULT_INTENT_HANDLER = Symbol("Document type list canHandleIntent");
var defaultIntentChecker = (intentName, params, _ref47) => {
  let {
    pane
  } = _ref47;
  var _a2, _b2;
  const isEdit = intentName === "edit";
  const isCreate = intentName === "create";
  const typedSpec = pane;
  const paneFilter = ((_a2 = typedSpec.options) == null ? void 0 : _a2.filter) || "";
  const paneParams = ((_b2 = typedSpec.options) == null ? void 0 : _b2.params) || {};
  const typeNames = typedSpec.schemaTypeName ? [typedSpec.schemaTypeName] : getTypeNamesFromFilter(paneFilter, paneParams);
  const initialValueTemplates = typedSpec.initialValueTemplates || [];
  if (isCreate && params.template) {
    return initialValueTemplates.some((tpl) => tpl.templateId === params.template);
  }
  return isEdit && params.id && typeNames.includes(params.type) || isCreate && typeNames.includes(params.type);
};
defaultIntentChecker.identity = DEFAULT_INTENT_HANDLER;
var __defProp$6 = Object.defineProperty;
var __defNormalProp$6 = (obj, key, value) => key in obj ? __defProp$6(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;
var __publicField$6 = (obj, key, value) => {
  __defNormalProp$6(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var InitialValueTemplateItemBuilder = class _InitialValueTemplateItemBuilder {
  constructor(_context, spec) {
    this._context = _context;
    __publicField$6(this, "spec");
    this.spec = spec ? spec : {};
  }
  /** Set initial value template item builder ID
   * @param id - initial value template item ID
   * @returns initial value template item based on ID provided. See {@link InitialValueTemplateItemBuilder}
   */
  id(id) {
    return this.clone({
      id
    });
  }
  /** Get initial value template item builder ID
   * @returns initial value template item ID. See {@link InitialValueTemplateItem}
   */
  getId() {
    return this.spec.id;
  }
  /** Set initial value template item title
   * @param title - initial value template item title
   * @returns initial value template item based on title provided. See {@link InitialValueTemplateItemBuilder}
   */
  title(title) {
    return this.clone({
      title
    });
  }
  /** Get initial value template item title
   * @returns initial value template item title. See {@link InitialValueTemplateItem}
   */
  getTitle() {
    return this.spec.title;
  }
  /** Set initial value template item description
   * @param description - initial value template item description
   * @returns initial value template item builder based on description provided. See {@link InitialValueTemplateItemBuilder}
   */
  description(description) {
    return this.clone({
      description
    });
  }
  /** Get initial value template item description
   * @returns initial value template item description. See {@link InitialValueTemplateItem}
   */
  getDescription() {
    return this.spec.description;
  }
  /** Set initial value template ID
   * @param templateId - initial value template item template ID
   * @returns initial value template item based builder on template ID provided. See {@link InitialValueTemplateItemBuilder}
   */
  templateId(templateId) {
    const paneId = this.spec.id || templateId;
    return this.clone({
      id: paneId,
      templateId
    });
  }
  /** Get initial value template item template ID
   * @returns initial value template item ID. See {@link InitialValueTemplateItem}
   */
  getTemplateId() {
    return this.spec.templateId;
  }
  /** Get initial value template item template parameters
   * @param parameters - initial value template item parameters
   * @returns initial value template item builder based on parameters provided. See {@link InitialValueTemplateItemBuilder}
   */
  parameters(parameters) {
    return this.clone({
      parameters
    });
  }
  /** Get initial value template item template parameters
   * @returns initial value template item parameters. See {@link InitialValueTemplateItem}
   */
  getParameters() {
    return this.spec.parameters;
  }
  /** Serialize initial value template item
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns initial value template item object based on the path, index and hint provided in options. See {@link InitialValueTemplateItem}
   */
  serialize() {
    let {
      path = [],
      index,
      hint
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      path: []
    };
    const {
      spec,
      _context
    } = this;
    const {
      templates
    } = _context;
    if (typeof spec.id !== "string" || !spec.id) {
      throw new SerializeError("`id` is required for initial value template item nodes", path, index, hint).withHelpUrl(HELP_URL.ID_REQUIRED);
    }
    if (!spec.templateId) {
      throw new SerializeError("template id (`templateId`) is required for initial value template item nodes", path, spec.id, hint).withHelpUrl(HELP_URL.ID_REQUIRED);
    }
    const template = templates.find((t) => t.id === spec.templateId);
    if (!template) {
      throw new SerializeError("template id (`templateId`) is required for initial value template item nodes", path, spec.id, hint).withHelpUrl(HELP_URL.ID_REQUIRED);
    }
    return {
      id: spec.id,
      templateId: spec.id,
      schemaType: template.schemaType,
      type: "initialValueTemplateItem",
      description: spec.description || template.description,
      title: spec.title || template.title,
      subtitle: spec.subtitle,
      icon: spec.icon || template.icon,
      initialDocumentId: spec.initialDocumentId,
      parameters: spec.parameters
    };
  }
  /** Clone generic view builder (allows for options overriding)
   * @param withSpec - initial value template item builder options. See {@link InitialValueTemplateItemBuilder}
   * @returns initial value template item builder based on the context and options provided. See {@link InitialValueTemplateItemBuilder}
   */
  clone() {
    let withSpec = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const builder = new _InitialValueTemplateItemBuilder(this._context);
    builder.spec = {
      ...this.spec,
      ...withSpec
    };
    return builder;
  }
};
function defaultInitialValueTemplateItems(context) {
  const {
    schema,
    getStructureBuilder,
    templates
  } = context;
  const typeNames = schema.getTypeNames();
  const ordered = templates.filter((tpl) => {
    var _a2;
    return !((_a2 = tpl.parameters) == null ? void 0 : _a2.length);
  }).sort((a, b) => typeNames.indexOf(a.schemaType) - typeNames.indexOf(b.schemaType));
  return ordered.map((tpl) => getStructureBuilder().initialValueTemplateItem(tpl.id));
}
function maybeSerializeInitialValueTemplateItem(item, index, path) {
  return item instanceof InitialValueTemplateItemBuilder ? item.serialize({
    path,
    index
  }) : item;
}
function menuItemsFromInitialValueTemplateItems(context, templateItems) {
  const {
    schema,
    templates
  } = context;
  return templateItems.map((item) => {
    const template = templates.find((t) => t.id === item.templateId);
    const title = item.title || (template == null ? void 0 : template.title) || "Create new";
    const params = (0, import_pickBy.default)({
      type: template && template.schemaType,
      template: item.templateId
    }, Boolean);
    const intentParams = item.parameters ? [params, item.parameters] : params;
    const schemaType = template && schema.get(template.schemaType);
    return new MenuItemBuilder(context).title(title).icon(template && template.icon || (schemaType == null ? void 0 : schemaType.icon) || ComposeIcon).intent({
      type: "create",
      params: intentParams
    }).serialize();
  });
}
var __defProp$5 = Object.defineProperty;
var __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;
var __publicField$5 = (obj, key, value) => {
  __defNormalProp$5(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
function noChildResolver() {
  return void 0;
}
var shallowIntentChecker = (intentName, params, _ref48) => {
  let {
    pane,
    index
  } = _ref48;
  return index <= 1 && defaultIntentChecker(intentName, params, {
    pane,
    index
  });
};
var GenericListBuilder = class {
  constructor() {
    __publicField$5(this, "initialValueTemplatesSpecified", false);
    __publicField$5(this, "spec", {});
  }
  /** Set generic list ID
   * @param id - generic list ID
   * @returns generic list builder based on ID provided.
   */
  id(id) {
    return this.clone({
      id
    });
  }
  /** Get generic list ID
   * @returns generic list ID
   */
  getId() {
    return this.spec.id;
  }
  /** Set generic list title
   * @param title - generic list title
   * @returns generic list builder based on title and ID provided.
   */
  title(title) {
    return this.clone({
      title,
      id: getStructureNodeId(title, this.spec.id)
    });
  }
  /** Get generic list title
   * @returns generic list title
   */
  getTitle() {
    return this.spec.title;
  }
  /** Set generic list layout
   * @param defaultLayout - generic list layout key.
   * @returns generic list builder based on layout provided.
   */
  defaultLayout(defaultLayout) {
    return this.clone({
      defaultLayout
    });
  }
  /** Get generic list layout
   * @returns generic list layout
   */
  getDefaultLayout() {
    return this.spec.defaultLayout;
  }
  /** Set generic list menu items
   * @param menuItems - generic list menu items. See {@link MenuItem} and {@link MenuItemBuilder}
   * @returns generic list builder based on menu items provided.
   */
  menuItems(menuItems) {
    return this.clone({
      menuItems
    });
  }
  /** Get generic list menu items
   * @returns generic list menu items
   */
  getMenuItems() {
    return this.spec.menuItems;
  }
  /** Set generic list menu item groups
   * @param menuItemGroups - generic list menu item groups. See {@link MenuItemGroup} and {@link MenuItemGroupBuilder}
   * @returns generic list builder based on menu item groups provided.
   */
  menuItemGroups(menuItemGroups) {
    return this.clone({
      menuItemGroups
    });
  }
  /** Get generic list menu item groups
   * @returns generic list menu item groups
   */
  getMenuItemGroups() {
    return this.spec.menuItemGroups;
  }
  /** Set generic list child
   * @param child - generic list child. See {@link Child}
   * @returns generic list builder based on child provided (clone).
   */
  child(child) {
    return this.clone({
      child
    });
  }
  /** Get generic list child
   * @returns generic list child
   */
  getChild() {
    return this.spec.child;
  }
  /** Set generic list can handle intent
   * @param canHandleIntent - generic list intent checker. See {@link IntentChecker}
   * @returns generic list builder based on can handle intent provided.
   */
  canHandleIntent(canHandleIntent) {
    return this.clone({
      canHandleIntent
    });
  }
  /** Get generic list can handle intent
   * @returns generic list can handle intent
   */
  getCanHandleIntent() {
    return this.spec.canHandleIntent;
  }
  /** Set generic list display options
   * @param enabled - allow / disallow for showing icons
   * @returns generic list builder based on display options (showIcons) provided.
   */
  showIcons() {
    let enabled = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
    return this.clone({
      displayOptions: {
        ...this.spec.displayOptions || {},
        showIcons: enabled
      }
    });
  }
  /** Get generic list display options
   * @returns generic list display options (specifically showIcons)
   */
  getShowIcons() {
    return this.spec.displayOptions ? this.spec.displayOptions.showIcons : void 0;
  }
  /** Set generic list initial value templates
   * @param templates - generic list initial value templates. See {@link InitialValueTemplateItem} and {@link InitialValueTemplateItemBuilder}
   * @returns generic list builder based on templates provided.
   */
  initialValueTemplates(templates) {
    this.initialValueTemplatesSpecified = true;
    return this.clone({
      initialValueTemplates: Array.isArray(templates) ? templates : [templates]
    });
  }
  /** Get generic list initial value templates
   * @returns generic list initial value templates
   */
  getInitialValueTemplates() {
    return this.spec.initialValueTemplates;
  }
  /** Serialize generic list
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns generic list object based on path provided in options. See {@link GenericList}
   */
  serialize() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      path: []
    };
    const id = this.spec.id || "";
    const path = options.path;
    const defaultLayout = this.spec.defaultLayout;
    if (defaultLayout && !layoutOptions.includes(defaultLayout)) {
      throw new SerializeError("`layout` must be one of ".concat(layoutOptions.map((item) => '"'.concat(item, '"')).join(", ")), path, id || options.index, this.spec.title);
    }
    const initialValueTemplates = (this.spec.initialValueTemplates || []).map((item, i) => maybeSerializeInitialValueTemplateItem(item, i, path));
    return {
      id: validateId(id, options.path, id || options.index),
      title: this.spec.title,
      type: "genericList",
      defaultLayout,
      child: this.spec.child || noChildResolver,
      canHandleIntent: this.spec.canHandleIntent || shallowIntentChecker,
      displayOptions: this.spec.displayOptions,
      initialValueTemplates,
      menuItems: (this.spec.menuItems || []).map((item, i) => maybeSerializeMenuItem(item, i, path)),
      menuItemGroups: (this.spec.menuItemGroups || []).map((item, i) => maybeSerializeMenuItemGroup(item, i, path))
    };
  }
};
var __defProp$4 = Object.defineProperty;
var __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;
var __publicField$4 = (obj, key, value) => {
  __defNormalProp$4(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var validateFilter = (spec, options) => {
  var _a2;
  const filter = ((_a2 = spec.options) == null ? void 0 : _a2.filter.trim()) || "";
  if (["*", "{"].includes(filter[0])) {
    throw new SerializeError("`filter` cannot start with `".concat(filter[0], "` - looks like you are providing a query, not a filter"), options.path, spec.id, spec.title).withHelpUrl(HELP_URL.QUERY_PROVIDED_FOR_FILTER);
  }
  return filter;
};
var createDocumentChildResolverForItem = (context) => (itemId, options) => {
  var _a2;
  const parentItem = options.parent;
  const template = ((_a2 = options.params) == null ? void 0 : _a2.template) ? context.templates.find((tpl) => tpl.id === options.params.template) : void 0;
  const type = template ? template.schemaType : parentItem.schemaTypeName || resolveTypeForDocument(context.getClient, itemId);
  return Promise.resolve(type).then((schemaType) => schemaType ? context.resolveDocumentNode({
    schemaType,
    documentId: itemId
  }) : new DocumentBuilder(context).id("editor").documentId(itemId).schemaType(""));
};
var DocumentListBuilder = class _DocumentListBuilder extends GenericListBuilder {
  constructor(_context, spec) {
    super();
    this._context = _context;
    __publicField$4(this, "spec");
    this.spec = spec || {};
    this.initialValueTemplatesSpecified = Boolean(spec == null ? void 0 : spec.initialValueTemplates);
  }
  /** Set API version
   * @param apiVersion - API version
   * @returns document list builder based on the options and API version provided. See {@link DocumentListBuilder}
   */
  apiVersion(apiVersion) {
    return this.clone({
      options: {
        ...this.spec.options || {
          filter: ""
        },
        apiVersion
      }
    });
  }
  /** Get API version
   * @returns API version
   */
  getApiVersion() {
    var _a2;
    return (_a2 = this.spec.options) == null ? void 0 : _a2.apiVersion;
  }
  /** Set Document list filter
   * @param filter - filter
   * @returns document list builder based on the options and filter provided. See {@link DocumentListBuilder}
   */
  filter(filter) {
    return this.clone({
      options: {
        ...this.spec.options || {},
        filter
      }
    });
  }
  /** Get Document list filter
   * @returns filter
   */
  getFilter() {
    var _a2;
    return (_a2 = this.spec.options) == null ? void 0 : _a2.filter;
  }
  /** Set Document list schema type name
   * @param type - schema type name. See {@link SchemaType}
   * @returns document list builder based on the schema type name provided. See {@link DocumentListBuilder}
   */
  schemaType(type) {
    const schemaTypeName = typeof type === "string" ? type : type.name;
    return this.clone({
      schemaTypeName
    });
  }
  /** Get Document list schema type name
   * @returns schema type name
   */
  getSchemaType() {
    return this.spec.schemaTypeName;
  }
  /** Set Document list options' parameters
   * @param params - parameters
   * @returns document list builder based on the options provided. See {@link DocumentListBuilder}
   */
  params(params) {
    return this.clone({
      options: {
        ...this.spec.options || {
          filter: ""
        },
        params
      }
    });
  }
  /** Get Document list options' parameters
   * @returns options
   */
  getParams() {
    var _a2;
    return (_a2 = this.spec.options) == null ? void 0 : _a2.params;
  }
  /** Set Document list default ordering
   * @param ordering - default sort ordering array. See {@link SortOrderingItem}
   * @returns document list builder based on ordering provided. See {@link DocumentListBuilder}
   */
  defaultOrdering(ordering) {
    if (!Array.isArray(ordering)) {
      throw new Error("`defaultOrdering` must be an array of order clauses");
    }
    return this.clone({
      options: {
        ...this.spec.options || {
          filter: ""
        },
        defaultOrdering: ordering
      }
    });
  }
  /** Get Document list default ordering
   * @returns default ordering. See {@link SortOrderingItem}
   */
  getDefaultOrdering() {
    var _a2;
    return (_a2 = this.spec.options) == null ? void 0 : _a2.defaultOrdering;
  }
  /** Serialize Document list
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns document list object based on path provided in options. See {@link DocumentList}
   */
  serialize() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      path: []
    };
    var _a2;
    if (typeof this.spec.id !== "string" || !this.spec.id) {
      throw new SerializeError("`id` is required for document lists", options.path, options.index, this.spec.title).withHelpUrl(HELP_URL.ID_REQUIRED);
    }
    if (!this.spec.options || !this.spec.options.filter) {
      throw new SerializeError("`filter` is required for document lists", options.path, this.spec.id, this.spec.title).withHelpUrl(HELP_URL.FILTER_REQUIRED);
    }
    return {
      ...super.serialize(options),
      type: "documentList",
      schemaTypeName: this.spec.schemaTypeName,
      child: this.spec.child || createDocumentChildResolverForItem(this._context),
      options: {
        ...this.spec.options,
        apiVersion: this.spec.options.apiVersion || // If this is a simple type filter, use modern API version - otherwise default to v1
        (((_a2 = this.spec.options) == null ? void 0 : _a2.filter) === "_type == $type" ? "2021-06-07" : "1"),
        filter: validateFilter(this.spec, options)
      }
    };
  }
  /** Clone Document list builder (allows for options overriding)
   * @param withSpec - override document list spec. See {@link PartialDocumentList}
   * @returns document list builder. See {@link DocumentListBuilder}
   */
  clone(withSpec) {
    const builder = new _DocumentListBuilder(this._context);
    builder.spec = {
      ...this.spec,
      ...withSpec || {}
    };
    if (!this.initialValueTemplatesSpecified) {
      builder.spec.initialValueTemplates = inferInitialValueTemplates(this._context, builder.spec);
    }
    if (!builder.spec.schemaTypeName) {
      builder.spec.schemaTypeName = inferTypeName(builder.spec);
    }
    return builder;
  }
  /** Get Document list spec
   * @returns document list spec. See {@link PartialDocumentList}
   */
  getSpec() {
    return this.spec;
  }
};
function inferInitialValueTemplates(context, spec) {
  const {
    document: document2
  } = context;
  const {
    schemaTypeName,
    options
  } = spec;
  const {
    filter,
    params
  } = options || {
    filter: "",
    params: {}
  };
  const typeNames = schemaTypeName ? [schemaTypeName] : Array.from(new Set(getTypeNamesFromFilter(filter, params)));
  if (typeNames.length === 0) {
    return void 0;
  }
  return typeNames.flatMap((schemaType) => document2.resolveNewDocumentOptions({
    type: "structure",
    schemaType
  })).map((option) => ({
    ...option,
    icon: ComposeIcon
  }));
}
function inferTypeName(spec) {
  const {
    options
  } = spec;
  const {
    filter,
    params
  } = options || {
    filter: "",
    params: {}
  };
  const typeNames = getTypeNamesFromFilter(filter, params);
  return typeNames.length === 1 ? typeNames[0] : void 0;
}
function getTypeNamesFromFilter(filter) {
  let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  let typeNames = getTypeNamesFromEqualityFilter(filter, params);
  if (typeNames.length === 0) {
    typeNames = getTypeNamesFromInTypesFilter(filter, params);
  }
  return typeNames;
}
function getTypeNamesFromEqualityFilter(filter) {
  let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const pattern = /\b_type\s*==\s*(['"].*?['"]|\$.*?(?:\s|$))|\B(['"].*?['"]|\$.*?(?:\s|$))\s*==\s*_type/g;
  const matches = [];
  let match;
  while ((match = pattern.exec(filter)) !== null) {
    matches.push(match[1] || match[2]);
  }
  return matches.map((candidate) => {
    const typeName = candidate[0] === "$" ? params[candidate.slice(1)] : candidate;
    const normalized = (typeName || "").trim().replace(/^["']|["']$/g, "");
    return normalized;
  }).filter(Boolean);
}
function getTypeNamesFromInTypesFilter(filter) {
  let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const pattern = /\b_type\s+in\s+\[(.*?)\]/;
  const matches = filter.match(pattern);
  if (!matches) {
    return [];
  }
  return matches[1].split(/,\s*/).map((match) => match.trim().replace(/^["']+|["']+$/g, "")).map((item) => item[0] === "$" ? params[item.slice(1)] : item).filter(Boolean);
}
var __defProp$3 = Object.defineProperty;
var __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;
var __publicField$3 = (obj, key, value) => {
  __defNormalProp$3(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var getArgType = (thing) => {
  if (thing instanceof ListBuilder) {
    return "ListBuilder";
  }
  if (isPromise(thing)) {
    return "Promise";
  }
  return Array.isArray(thing) ? "array" : typeof thing;
};
var isListItem = (item) => {
  return item.type === "listItem";
};
var defaultCanHandleIntent = (intentName, params, context) => {
  const pane = context.pane;
  const items = pane.items || [];
  return items.filter(isDocumentListItem).some((item) => item.schemaType.name === params.type && item._id === params.id) || shallowIntentChecker(intentName, params, context);
};
var resolveChildForItem = (itemId, options) => {
  const parentItem = options.parent;
  const items = parentItem.items.filter(isListItem);
  const target = (items.find((item) => item.id === itemId) || {
    child: void 0
  }).child;
  if (!target || typeof target !== "function") {
    return target;
  }
  return typeof target === "function" ? target(itemId, options) : target;
};
function maybeSerializeListItem(item, index, path) {
  if (item instanceof ListItemBuilder) {
    return item.serialize({
      path,
      index
    });
  }
  const listItem = item;
  if (listItem && listItem.type === "divider") {
    return item;
  }
  if (!listItem || listItem.type !== "listItem") {
    const gotWhat = listItem && listItem.type || getArgType(listItem);
    const helpText = gotWhat === "array" ? " - did you forget to spread (...moreItems)?" : "";
    throw new SerializeError('List items must be of type "listItem", got "'.concat(gotWhat, '"').concat(helpText), path, index).withHelpUrl(HELP_URL.INVALID_LIST_ITEM);
  }
  return item;
}
function isPromise(thing) {
  return isRecord$2(thing) && typeof thing.then === "function";
}
var ListBuilder = class _ListBuilder extends GenericListBuilder {
  constructor(_context, spec) {
    super();
    this._context = _context;
    __publicField$3(this, "spec");
    this.spec = spec ? spec : {};
    this.initialValueTemplatesSpecified = Boolean(spec && spec.initialValueTemplates);
  }
  /**
   * Set list builder based on items provided
   * @param items - list items. See {@link ListItemBuilder}, {@link ListItem} and {@link Divider}
   * @returns list builder based on items provided. See {@link ListBuilder}
   */
  items(items) {
    return this.clone({
      items
    });
  }
  /** Get list builder items
   * @returns list items. See {@link BuildableList}
   */
  getItems() {
    return this.spec.items;
  }
  /** Serialize list builder
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns list based on path in options. See {@link List}
   */
  serialize() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      path: []
    };
    const id = this.spec.id;
    if (typeof id !== "string" || !id) {
      throw new SerializeError("`id` is required for lists", options.path, options.index).withHelpUrl(HELP_URL.ID_REQUIRED);
    }
    const items = typeof this.spec.items === "undefined" ? [] : this.spec.items;
    if (!Array.isArray(items)) {
      throw new SerializeError("`items` must be an array of items", options.path, options.index).withHelpUrl(HELP_URL.LIST_ITEMS_MUST_BE_ARRAY);
    }
    const path = (options.path || []).concat(id);
    const serializedItems = items.map((item, index) => maybeSerializeListItem(item, index, path));
    const dupes = serializedItems.filter((val, i) => (0, import_find.default)(serializedItems, {
      id: val.id
    }, i + 1));
    if (dupes.length > 0) {
      const dupeIds = dupes.map((item) => item.id).slice(0, 5);
      const dupeDesc = dupes.length > 5 ? "".concat(dupeIds.join(", "), "...") : dupeIds.join(", ");
      throw new SerializeError("List items with same ID found (".concat(dupeDesc, ")"), options.path, options.index).withHelpUrl(HELP_URL.LIST_ITEM_IDS_MUST_BE_UNIQUE);
    }
    return {
      ...super.serialize(options),
      type: "list",
      canHandleIntent: this.spec.canHandleIntent || defaultCanHandleIntent,
      child: this.spec.child || resolveChildForItem,
      items: serializedItems
    };
  }
  /**
   * Clone list builder and return new list builder based on context and spec provided
   * @param withSpec - list options. See {@link BuildableList}
   * @returns new list builder based on context and spec provided. See {@link ListBuilder}
   */
  clone(withSpec) {
    const builder = new _ListBuilder(this._context);
    builder.spec = {
      ...this.spec,
      ...withSpec || {}
    };
    return builder;
  }
};
var __defProp$2 = Object.defineProperty;
var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;
var __publicField$2 = (obj, key, value) => {
  __defNormalProp$2(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var ListItemBuilder = class _ListItemBuilder {
  constructor(_context, spec) {
    this._context = _context;
    __publicField$2(this, "spec");
    this.spec = spec ? spec : {};
  }
  /**
   * Set list item ID
   * @returns list item builder based on ID provided. See {@link ListItemBuilder}
   */
  id(id) {
    return this.clone({
      id
    });
  }
  /**
   * Get list item ID
   * @returns list item ID. See {@link PartialListItem}
   */
  getId() {
    return this.spec.id;
  }
  /**
   * Set list item title
   * @returns list item builder based on title provided. See {@link ListItemBuilder}
   */
  title(title) {
    return this.clone({
      title,
      id: getStructureNodeId(title, this.spec.id)
    });
  }
  /**
   * Get list item title
   * @returns list item title. See {@link PartialListItem}
   */
  getTitle() {
    return this.spec.title;
  }
  /**
   * Set list item icon
   * @returns list item builder based on icon provided. See {@link ListItemBuilder}
   */
  icon(icon) {
    return this.clone({
      icon
    });
  }
  /**
   * Set if list item should show icon
   * @returns list item builder based on showIcon provided. See {@link ListItemBuilder}
   */
  showIcon() {
    let enabled = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
    return this.clone({
      displayOptions: {
        ...this.spec.displayOptions || {},
        showIcon: enabled
      }
    });
  }
  /**
   * Check if list item should show icon
   * @returns true if it should show the icon, false if not, undefined if not set
   */
  getShowIcon() {
    return this.spec.displayOptions ? this.spec.displayOptions.showIcon : void 0;
  }
  /**
   *Get list item icon
   * @returns list item icon. See {@link PartialListItem}
   */
  getIcon() {
    return this.spec.icon;
  }
  /**
   * Set list item child
   * @param child - list item child. See {@link UnserializedListItemChild}
   * @returns list item builder based on child provided. See {@link ListItemBuilder}
   */
  child(child) {
    return this.clone({
      child
    });
  }
  /**
   * Get list item child
   * @returns list item child. See {@link PartialListItem}
   */
  getChild() {
    return this.spec.child;
  }
  /**
   * Set list item schema type
   * @param schemaType - list item schema type. See {@link SchemaType}
   * @returns list item builder based on schema type provided. See {@link ListItemBuilder}
   */
  schemaType(schemaType) {
    return this.clone({
      schemaType
    });
  }
  /**
   * Get list item schema type
   * @returns list item schema type. See {@link PartialListItem}
   */
  getSchemaType() {
    const schemaType = this.spec.schemaType;
    if (typeof schemaType === "string") {
      return this._context.schema.get(schemaType);
    }
    return this.spec.schemaType;
  }
  /** Serialize list item builder
   * @param options - serialization options. See {@link ListItemSerializeOptions}
   * @returns list item node based on path provided in options. See {@link ListItem}
   */
  serialize() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      path: []
    };
    const {
      id,
      title,
      child
    } = this.spec;
    if (typeof id !== "string" || !id) {
      throw new SerializeError("`id` is required for list items", options.path, options.index).withHelpUrl(HELP_URL.ID_REQUIRED);
    }
    if (!options.titleIsOptional && (typeof title !== "string" || !title)) {
      throw new SerializeError("`title` is required for list items", options.path, id).withHelpUrl(HELP_URL.TITLE_REQUIRED);
    }
    let schemaType = this.spec.schemaType;
    if (typeof schemaType === "string") {
      const type = this._context.schema.get(schemaType);
      if (!type) {
        throw new SerializeError('Could not find type "'.concat(schemaType, '" in schema'), options.path, id).withHelpUrl(HELP_URL.SCHEMA_TYPE_NOT_FOUND);
      }
      schemaType = type;
    }
    const serializeOptions = {
      path: options.path.concat(id),
      hint: "child"
    };
    let listChild = child instanceof ComponentBuilder || child instanceof DocumentListBuilder || child instanceof DocumentBuilder || child instanceof ListBuilder ? child.serialize(serializeOptions) : child;
    if (typeof listChild === "function") {
      const originalChild = listChild;
      listChild = (itemId, childOptions) => {
        return originalChild(itemId, {
          ...childOptions,
          serializeOptions
        });
      };
    }
    return {
      ...this.spec,
      id: validateId(id, options.path, options.index),
      schemaType,
      child: listChild,
      title,
      type: "listItem"
    };
  }
  /** Clone list item builder
   * @param withSpec - partial list item options. See {@link PartialListItem}
   * @returns list item builder based on context and spec provided. See {@link ListItemBuilder}
   */
  clone(withSpec) {
    const builder = new _ListItemBuilder(this._context);
    builder.spec = {
      ...this.spec,
      ...withSpec || {}
    };
    return builder;
  }
};
var __defProp$1 = Object.defineProperty;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;
var __publicField$1 = (obj, key, value) => {
  __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var createDefaultChildResolver = (context, spec) => (documentId) => {
  const schemaType = spec.schemaType && (typeof spec.schemaType === "string" ? spec.schemaType : spec.schemaType.name);
  return schemaType ? context.resolveDocumentNode({
    schemaType,
    documentId
  }) : new DocumentBuilder(context).id("documentEditor").documentId(documentId);
};
var DocumentListItemBuilder = class _DocumentListItemBuilder extends ListItemBuilder {
  constructor(_context, spec) {
    super(_context, spec);
    this._context = _context;
    __publicField$1(this, "spec");
    this.spec = spec ? spec : {};
  }
  /**
   * Serialize document list item
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns document list item object based on path provided in options. See {@link DocumentListItem}
   */
  serialize() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      path: []
    };
    const spec = super.serialize({
      ...options,
      titleIsOptional: true
    });
    if (!spec.schemaType) {
      throw new SerializeError("`schemaType` is required for document list items", options.path, options.index).withHelpUrl(HELP_URL.SCHEMA_TYPE_REQUIRED);
    }
    const child = spec.child || createDefaultChildResolver(this._context, spec);
    return {
      ...spec,
      child,
      schemaType: spec.schemaType,
      _id: spec.id
    };
  }
  /** Clone Document list item builder (allows for options overriding)
   * @param withSpec - Document list item builder options. See {@link PartialDocumentListItem}
   * @returns document list item builder. See {@link DocumentListItemBuilder}
   */
  clone(withSpec) {
    const builder = new _DocumentListItemBuilder(this._context);
    builder.spec = {
      ...this.spec,
      ...withSpec || {}
    };
    return builder;
  }
};
function isDocumentListItem(item) {
  return isRecord$2(item) && typeof item.schemaType !== "undefined" && typeof item._id === "string";
}
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var DocumentTypeListBuilder = class _DocumentTypeListBuilder extends DocumentListBuilder {
  constructor(_context, spec) {
    super(_context);
    this._context = _context;
    __publicField(this, "spec");
    this.spec = spec ? spec : {};
  }
  /**
   * Set Document type list child
   * @param child - Child component. See {@link Child}
   * @returns document type list builder based on child component provided without default intent handler. See {@link DocumentTypeListBuilder}
   */
  child(child) {
    return this.cloneWithoutDefaultIntentHandler({
      child
    });
  }
  /** Clone Document type list builder (allows for options overriding)
   * @param withSpec - Document type list builder options. See {@link PartialDocumentList}
   * @returns document type list builder. See {@link DocumentTypeListBuilder}
   */
  clone(withSpec) {
    const parent = super.clone(withSpec);
    const builder = new _DocumentTypeListBuilder(this._context);
    builder.spec = {
      ...this.spec,
      ...parent.getSpec(),
      ...withSpec || {}
    };
    return builder;
  }
  /** Clone Document type list builder (allows for options overriding) and remove default intent handler
   * @param withSpec - Document type list builder options. See {@link PartialDocumentList}
   * @returns document type list builder without default intent handler. See {@link DocumentTypeListBuilder}
   */
  cloneWithoutDefaultIntentHandler(withSpec) {
    const parent = super.clone(withSpec);
    const builder = new _DocumentTypeListBuilder(this._context);
    const canHandleIntent = this.spec.canHandleIntent;
    const shouldOverride = canHandleIntent && canHandleIntent.identity === DEFAULT_INTENT_HANDLER;
    const override = shouldOverride ? {
      canHandleIntent: void 0
    } : {};
    builder.spec = {
      ...parent.getSpec(),
      ...this.spec,
      ...withSpec || {},
      ...override
    };
    return builder;
  }
};
function shouldShowIcon(schemaType) {
  const preview = schemaType.preview;
  return Boolean(preview && (preview.prepare || preview.select && preview.select.media));
}
var BUNDLED_DOC_TYPES = ["sanity.imageAsset", "sanity.fileAsset"];
function isBundledDocType(typeName) {
  return BUNDLED_DOC_TYPES.includes(typeName);
}
function isDocumentType(schemaType) {
  var _a2;
  return ((_a2 = schemaType.type) == null ? void 0 : _a2.name) === "document";
}
function isList(collection) {
  return collection.type === "list";
}
function getDocumentTypes(_ref49) {
  let {
    schema
  } = _ref49;
  return schema.getTypeNames().filter((n) => {
    const schemaType = schema.get(n);
    return schemaType && isDocumentType(schemaType);
  }).filter((n) => !isBundledDocType(n));
}
function getDocumentTypeListItems(context) {
  const types = getDocumentTypes(context);
  return types.map((typeName) => getDocumentTypeListItem(context, typeName));
}
function getDocumentTypeListItem(context, typeName) {
  const {
    schema
  } = context;
  const type = schema.get(typeName);
  if (!type) {
    throw new Error('Schema type with name "'.concat(typeName, '" not found'));
  }
  const title = type.title || (0, import_startCase.default)(typeName);
  return new ListItemBuilder(context).id(typeName).title(title).schemaType(type).child((id, childContext) => {
    const parent = childContext.parent;
    const parentItem = isList(parent) ? parent.items.find((item) => item.id === id) : null;
    let list = getDocumentTypeList(context, typeName);
    if (parentItem && parentItem.title) {
      list = list.title(parentItem.title);
    }
    return list;
  });
}
function getDocumentTypeList(context, typeNameOrSpec) {
  const {
    schema,
    resolveDocumentNode
  } = context;
  const schemaType = typeof typeNameOrSpec === "string" ? typeNameOrSpec : typeNameOrSpec.schemaType;
  const typeName = typeof schemaType === "string" ? schemaType : schemaType.name;
  const spec = typeof typeNameOrSpec === "string" ? {
    schemaType
  } : typeNameOrSpec;
  const type = schema.get(typeName);
  if (!type) {
    throw new Error('Schema type with name "'.concat(typeName, '" not found'));
  }
  const title = type.title || (0, import_startCase.default)(typeName);
  const showIcons = shouldShowIcon(type);
  return new DocumentTypeListBuilder(context).id(spec.id || typeName).title(spec.title || title).filter("_type == $type").params({
    type: typeName
  }).schemaType(type).showIcons(showIcons).defaultOrdering(DEFAULT_SELECTED_ORDERING_OPTION.by).menuItemGroups(spec.menuItemGroups || [{
    id: "sorting",
    title: "Sort"
  }, {
    id: "layout",
    title: "Layout"
  }, {
    id: "actions",
    title: "Actions"
  }]).child(spec.child || ((documentId) => resolveDocumentNode({
    schemaType: typeName,
    documentId
  }))).canHandleIntent(spec.canHandleIntent || defaultIntentChecker).menuItems(spec.menuItems || [
    // Create new (from action button) will be added in serialization step of GenericList
    // Sort by <Y>
    ...getOrderingMenuItemsForSchemaType(context, type),
    // Display as <Z>
    new MenuItemBuilder(context).group("layout").title("Compact view").icon(StackCompactIcon).action("setLayout").params({
      layout: "default"
    }),
    new MenuItemBuilder(context).group("layout").title("Detailed view").icon(StackIcon).action("setLayout").params({
      layout: "detail"
    })
    // Create new (from menu) will be added in serialization step of GenericList
  ]);
}
function hasIcon(schemaType) {
  if (!schemaType || typeof schemaType === "string") {
    return false;
  }
  return Boolean(schemaType.icon);
}
function getDefaultStructure(context) {
  const items = getDocumentTypeListItems(context);
  return new ListBuilder(context).id("__root__").title("Content").items(items).showIcons(items.some((item) => hasIcon(item.getSchemaType())));
}
function createStructureBuilder(_ref50) {
  let {
    defaultDocumentNode,
    source
  } = _ref50;
  const configContext = getConfigContextFromSource(source);
  const context = {
    ...source,
    getStructureBuilder: () => structureBuilder,
    resolveDocumentNode: (options) => {
      let builder = (defaultDocumentNode == null ? void 0 : defaultDocumentNode(structureBuilder, {
        ...options,
        ...configContext
      })) || new DocumentBuilder(context);
      if (!builder.getId()) {
        builder = builder.id("documentEditor");
      }
      if (options.documentId) {
        builder = builder.documentId(getPublishedId(options.documentId));
      }
      return builder.schemaType(options.schemaType);
    }
  };
  const structureBuilder = {
    defaults: () => getDefaultStructure(context),
    documentTypeList: function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return getDocumentTypeList(context, ...args);
    },
    documentTypeListItem: function() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return getDocumentTypeListItem(context, ...args);
    },
    documentTypeListItems: function() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      return getDocumentTypeListItems(context, ...args);
    },
    document: function() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      return new DocumentBuilder(context, ...args);
    },
    documentWithInitialValueTemplate: function() {
      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }
      return documentFromEditorWithInitialValue(context, ...args);
    },
    defaultDocument: context.resolveDocumentNode,
    list: function() {
      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        args[_key6] = arguments[_key6];
      }
      return new ListBuilder(context, ...args);
    },
    listItem: function() {
      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        args[_key7] = arguments[_key7];
      }
      return new ListItemBuilder(context, ...args);
    },
    menuItem: function() {
      for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
        args[_key8] = arguments[_key8];
      }
      return new MenuItemBuilder(context, ...args);
    },
    menuItemGroup: function() {
      for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
        args[_key9] = arguments[_key9];
      }
      return new MenuItemGroupBuilder(context, ...args);
    },
    menuItemsFromInitialValueTemplateItems: function() {
      for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
        args[_key10] = arguments[_key10];
      }
      return menuItemsFromInitialValueTemplateItems(context, ...args);
    },
    documentList: function() {
      for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
        args[_key11] = arguments[_key11];
      }
      return new DocumentListBuilder(context, ...args);
    },
    documentListItem: function() {
      for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
        args[_key12] = arguments[_key12];
      }
      return new DocumentListItemBuilder(context, ...args);
    },
    orderingMenuItem: function() {
      for (var _len13 = arguments.length, args = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {
        args[_key13] = arguments[_key13];
      }
      return getOrderingMenuItem(context, ...args);
    },
    orderingMenuItemsForType: function() {
      for (var _len14 = arguments.length, args = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {
        args[_key14] = arguments[_key14];
      }
      return getOrderingMenuItemsForSchemaType(context, ...args);
    },
    editor: function() {
      for (var _len15 = arguments.length, args = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {
        args[_key15] = arguments[_key15];
      }
      return documentFromEditor(context, ...args);
    },
    defaultInitialValueTemplateItems: function() {
      for (var _len16 = arguments.length, args = new Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {
        args[_key16] = arguments[_key16];
      }
      return defaultInitialValueTemplateItems(context, ...args);
    },
    initialValueTemplateItem: (templateId, parameters) => new InitialValueTemplateItemBuilder(context, {
      id: templateId,
      parameters,
      templateId
    }),
    component: (spec) => {
      return (0, import_react_is.isValidElementType)(spec) ? new ComponentBuilder().component(spec) : new ComponentBuilder(spec);
    },
    divider: () => ({
      id: (0, import_uniqueId.default)("__divider__"),
      type: "divider"
    }),
    view: views,
    context
  };
  return structureBuilder;
}
function DeskToolProvider(_ref51) {
  let {
    defaultDocumentNode,
    structure: resolveStructure,
    children
  } = _ref51;
  const [layoutCollapsed, setLayoutCollapsed] = (0, import_react.useState)(false);
  const source = useSource();
  const configContext = useConfigContextFromSource(source);
  const documentStore = useDocumentStore();
  const S = (0, import_react.useMemo)(() => {
    return createStructureBuilder({
      defaultDocumentNode,
      source
    });
  }, [defaultDocumentNode, source]);
  const rootPaneNode = (0, import_react.useMemo)(() => {
    if (resolveStructure)
      return resolveStructure(S, {
        ...configContext,
        documentStore
      });
    return S.defaults();
  }, [S, resolveStructure, configContext, documentStore]);
  const features = (0, import_react.useMemo)(() => ({
    backButton: layoutCollapsed,
    resizablePanes: !layoutCollapsed,
    reviewChanges: !layoutCollapsed,
    splitPanes: !layoutCollapsed,
    splitViews: !layoutCollapsed
  }), [layoutCollapsed]);
  const deskTool2 = (0, import_react.useMemo)(() => {
    return {
      features,
      layoutCollapsed,
      setLayoutCollapsed,
      rootPaneNode,
      structureContext: S.context
    };
  }, [features, layoutCollapsed, rootPaneNode, S.context]);
  return (0, import_jsx_runtime.jsx)(DeskToolContext.Provider, {
    value: deskTool2,
    children
  });
}

export {
  require_isNumber,
  require_camelCase,
  require_kebabCase,
  Delay,
  DocTitle,
  PaneItemPreview,
  PaneRouterContext,
  BackLink,
  ChildLink,
  ReferenceChildLink,
  ParameterizedLink,
  usePaneRouter,
  ConfirmDeleteDialogContainer,
  PaneContextMenuButton,
  PANE_COLLAPSED_WIDTH,
  PANE_DEFAULT_MIN_WIDTH,
  PaneLayoutContext,
  usePaneLayout,
  Pane,
  usePane,
  PaneContent,
  PaneFooter,
  PaneHeader,
  PaneHeaderActionButton,
  Root$6,
  isMenuNodeButton,
  isNotMenuNodeButton,
  resolveMenuNodes,
  PaneHeaderActions,
  HistoryRestoreAction,
  useDocumentPane,
  _DEBUG,
  LOADING_PANE,
  DOCUMENT_PANEL_PORTAL_ELEMENT,
  setActivePanes,
  DOCUMENT_PANEL_MIN_WIDTH,
  DOCUMENT_PANEL_INITIAL_MIN_WIDTH,
  DOCUMENT_INSPECTOR_MIN_WIDTH,
  DOCUMENT_INSPECTOR_MAX_WIDTH,
  DocumentInspectorHeader,
  useDeskTool,
  Resizable,
  TimelineMenu,
  deskTool,
  DocumentPaneProvider,
  SerializeError,
  HELP_URL,
  maybeSerializeMenuItem,
  MenuItemBuilder,
  getOrderingMenuItem,
  getOrderingMenuItemsForSchemaType,
  maybeSerializeMenuItemGroup,
  MenuItemGroupBuilder,
  ComponentBuilder,
  GenericViewBuilder,
  maybeSerializeView,
  ComponentViewBuilder,
  FormViewBuilder,
  form,
  component,
  DocumentBuilder,
  documentFromEditor,
  documentFromEditorWithInitialValue,
  DEFAULT_INTENT_HANDLER,
  defaultIntentChecker,
  InitialValueTemplateItemBuilder,
  defaultInitialValueTemplateItems,
  maybeSerializeInitialValueTemplateItem,
  menuItemsFromInitialValueTemplateItems,
  shallowIntentChecker,
  GenericListBuilder,
  DocumentListBuilder,
  getTypeNamesFromFilter,
  ListBuilder,
  ListItemBuilder,
  DocumentListItemBuilder,
  isDocumentListItem,
  DocumentTypeListBuilder,
  createStructureBuilder,
  DeskToolProvider
};
//# sourceMappingURL=chunk-WVJ5EO4Q.js.map
